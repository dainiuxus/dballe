#!/usr/bin/python3

import argparse
import multiprocessing
import contextlib
from collections import defaultdict
import os
import sys
import warnings
import shutil
import logging
import traceback
import tempfile
import ast
from termcolor import cprint
import importlib
import json

log = logging.getLogger()


class RunEnv:
    """
    Test environment for python tests
    """
    TEST_BUFR = "extra/bufr/synop-sunshine.bufr"

    def __init__(self):
        self.globals = dict(globals())
        self.locals = dict(locals())
        self.assigned = set()
        self.wanted = set()

        # Import modules expected by the snippets
        for modname in ("dballe", "wreport", "os", "datetime"):
            self.globals[modname] = importlib.__import__(modname)

    def check_reqs(self, entry):
        """
        Check if the snippet expects some well-known variables to be defined
        """
        tree = ast.parse(entry["code"], entry["src"], "exec")
        for node in ast.walk(tree):
            if isinstance(node, ast.Assign):
                if len(node.targets) != 1:
                    continue
                if not isinstance(node.targets[0], ast.Name):
                    continue
                self.assigned.add(node.targets[0].id)
            elif isinstance(node, ast.Attribute):
                if not isinstance(node.value, ast.Name):
                    continue
                if node.value.id in self.assigned:
                    continue
                self.wanted.add(node.value.id)
            elif isinstance(node, ast.With):
                if len(node.items) != 1:
                    continue
                self.assigned.add(node.items[0].optional_vars.id)

    # Provide some assertion methods the snippets can use

    def assertEqual(self, a, b):
        if a != b:
            raise AssertionError(f"{a!r} != {b!r}")

    @contextlib.contextmanager
    def setup(self):
        import dballe

        # Build a test environment in a temporary directory
        with tempfile.TemporaryDirectory() as root:
            shutil.copy(self.TEST_BUFR, os.path.join(root, "test.bufr"))
            db = dballe.DB.connect("sqlite:" + os.path.join(root, "db.sqlite?wipe=yes"))
            importer = dballe.Importer("BUFR")
            with importer.from_file(os.path.join(root, "test.bufr")) as f:
                db.import_messages(f)

            # Create well-known variables if needed
            if "db" in self.wanted or "tr" in self.wanted or "explorer" in self.wanted:
                self.locals["db"] = db
            if "explorer" in self.wanted:
                self.locals["explorer"] = dballe.Explorer()
                with self.locals["explorer"].rebuild() as update:
                    with self.locals["db"].transaction() as tr:
                        update.add_db(tr)
            if "tr" in self.wanted:
                self.locals["tr"] = self.locals["db"].transaction()
            if "msg" in self.wanted:
                importer = dballe.Importer("BUFR")
                with importer.from_file("extra/bufr/synop-sunshine.bufr") as f:
                    for msg in f:
                        self.locals["msg"] = msg[0]

            # Set env variables the snippets may use
            os.environ["DBA_DB"] = "mem:"

            # Run the code, in the temp directory, discarding stdout
            with open("/dev/null", "wt") as null:
                orig = sys.stdout
                curdir = os.getcwd()
                sys.stdout = null
                os.chdir(root)
                try:
                    yield
                finally:
                    sys.stdout = orig
                    os.chdir(curdir)

    def run(self, code):
        """
        Run a compiled test snippet
        """
        exec(code, self.globals, self.locals)


def run_python_test(entry):
    """
    Run a collected python code snippet, annotating its information with run
    results
    """
    def store_exc(entry):
        type, value, tb = sys.exc_info()
        for frame, lineno in traceback.walk_tb(tb):
            if frame.f_code.co_filename == entry["src"]:
                entry["exception"] = (lineno, str(value))
        if "exception" not in entry:
            entry["exception"] = None, traceback.format_exc()

    with warnings.catch_warnings(record=True) as w:
        env = RunEnv()

        warnings.simplefilter("always")
        entry["warnings"] = w

        try:
            code = compile(entry["code"], entry["src"], "exec")
        except Exception:
            entry["result"] = "fail-compile"
            store_exc(entry)
            return entry

        env.check_reqs(entry)

        with env.setup():
            try:
                env.run(code)
            except Exception:
                entry["result"] = "fail-run"
                store_exc(entry)
                return entry

    entry["result"] = "ok"
    return entry


def format_python_result(entry):
    """
    Colorful formatting of a code snippet annotated with run results
    """
    if "exception" in entry:
        color = "red"
        ok = False
    elif entry["warnings"]:
        color = "yellow"
        ok = False
    else:
        color = "green"
        ok = True

    cprint(f"{entry['src']}: {entry['result']}", color, attrs=["bold"])

    if "exception" in entry:
        lineno, msg = entry["exception"]
        for idx, line in enumerate(entry["code"].splitlines(), start=1):
            cprint(f" {idx:2d} {line}", "red" if idx == lineno else "grey", attrs=["bold"])
            if idx == lineno:
                cprint(f"  ↪ {msg}", "red")

        if lineno is None:
            for line in msg.splitlines():
                cprint(f"  ↪ {line}", "red")
        elif lineno > idx:
            cprint(f"  ↪ {msg}", "red")

    if entry["warnings"]:
        for w in entry["warnings"]:
            cprint(f" W line {w.lineno}: {w.category}, {w.message}", "yellow")

    if not ok:
        print()


def run_tests(entries):
    """
    Run a list of collected test snippets
    """
    by_lang = defaultdict(list)
    for e in entries:
        lang = e["lang"]
        if lang == "default":
            lang = "python"
        by_lang[lang].append(e)

    entries = by_lang["python"]
    if entries:
        with multiprocessing.Pool(1) as p:
            entries = p.map(run_python_test, entries)

        for entry in entries:
            format_python_result(entry)

    # Only python supported so far


def main():
    parser = argparse.ArgumentParser(description="Run code found in documentation code blocks")
    parser.add_argument("--verbose", "-v", action="store_true", help="verbose output")
    parser.add_argument("--debug", action="store_true", help="debug output")
    parser.add_argument("code", action="store", nargs="?", default="doc/test_code.json",
                        help="JSON file with the collected test code")
    args = parser.parse_args()

    # Setup logging
    FORMAT = "%(asctime)-15s %(levelname)s %(message)s"
    if args.debug:
        logging.basicConfig(level=logging.DEBUG, stream=sys.stderr, format=FORMAT)
    elif args.verbose:
        logging.basicConfig(level=logging.INFO, stream=sys.stderr, format=FORMAT)
    else:
        logging.basicConfig(level=logging.WARN, stream=sys.stderr, format=FORMAT)

    with open(args.code, "rt") as fd:
        entries = json.load(fd)

    run_tests(entries)


if __name__ == "__main__":
    main()
