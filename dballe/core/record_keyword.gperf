/*
 * dballe/record_keyword - fast resolution of string record keywords
 *
 * Copyright (C) 2005--2010  ARPA-SIM <urpsim@smr.arpa.emr.it>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 *
 * Author: Enrico Zini <enrico@enricozini.com>
 */

%define slot-name tag
%define class-name RecordKeywords
%define lookup-function-name find
%struct-type
%language=C++
%global-table
%compare-strncmp
/* Using %switch may be faster (remember to check when doing optimizations) */

%{
#include <string.h>
#include <limits.h>
#include "dballe/core/var.h"
#include "dballe/core/record.h"

using namespace wreport;

namespace dballe {
%}

struct tagdef { const char* tag; dba_keyword index; };
%%
priority,    DBA_KEY_PRIORITY
priomax,     DBA_KEY_PRIOMAX
priomin,     DBA_KEY_PRIOMIN
rep_cod,     DBA_KEY_REP_COD
rep_memo,    DBA_KEY_REP_MEMO
ana_id,      DBA_KEY_ANA_ID
mobile,      DBA_KEY_MOBILE
ident,       DBA_KEY_IDENT
lat,         DBA_KEY_LAT
lon,         DBA_KEY_LON
latmax,      DBA_KEY_LATMAX
latmin,      DBA_KEY_LATMIN
lonmax,      DBA_KEY_LONMAX
lonmin,      DBA_KEY_LONMIN
year,        DBA_KEY_YEAR
month,       DBA_KEY_MONTH
day,         DBA_KEY_DAY
hour,        DBA_KEY_HOUR
min,         DBA_KEY_MIN
sec,         DBA_KEY_SEC
yearmax,     DBA_KEY_YEARMAX
yearmin,     DBA_KEY_YEARMIN
monthmax,    DBA_KEY_MONTHMAX
monthmin,    DBA_KEY_MONTHMIN
daymax,      DBA_KEY_DAYMAX
daymin,      DBA_KEY_DAYMIN
hourmax,     DBA_KEY_HOURMAX
hourmin,     DBA_KEY_HOURMIN
minumax,     DBA_KEY_MINUMAX
minumin,     DBA_KEY_MINUMIN
secmax,      DBA_KEY_SECMAX
secmin,      DBA_KEY_SECMIN
leveltype1,  DBA_KEY_LEVELTYPE1
l1,          DBA_KEY_L1
leveltype2,  DBA_KEY_LEVELTYPE2
l2,          DBA_KEY_L2
pindicator,  DBA_KEY_PINDICATOR
p1,          DBA_KEY_P1
p2,          DBA_KEY_P2
var,         DBA_KEY_VAR
varlist,     DBA_KEY_VARLIST
context_id,  DBA_KEY_CONTEXT_ID
query,       DBA_KEY_QUERY
ana_filter,  DBA_KEY_ANA_FILTER
data_filter, DBA_KEY_DATA_FILTER
attr_filter, DBA_KEY_ATTR_FILTER
limit,		 DBA_KEY_LIMIT
var_related, DBA_KEY_VAR_RELATED
%%

#define DEF_STRING(len) 0, 0, len, 0, len*8
#define DEF_MAXINT 0, 0, 10, 0, 31
#define DEF_INT(digits) 0, 0, digits, 0, digits*8

namespace {

struct keyword_infos
{
	struct _Varinfo infos[DBA_KEY_COUNT];

	keyword_infos()
	{
		infos[DBA_KEY_PRIORITY	 ].set(0, "Priority of this type of report",         "NUMBER", DEF_MAXINT);
		infos[DBA_KEY_PRIOMAX	 ].set(0, "Maximum priority of reports queried",     "NUMBER", DEF_MAXINT);
		infos[DBA_KEY_PRIOMIN	 ].set(0, "Minimum priority of reports queried",     "NUMBER", DEF_MAXINT);
		infos[DBA_KEY_REP_COD	 ].set(0, "Type of report",                          "NUMBER", DEF_MAXINT);
		infos[DBA_KEY_REP_MEMO	 ].set(0, "Mnemonic alias for type of report",     "CCITTIA5", DEF_STRING(20));
		infos[DBA_KEY_ANA_ID	 ].set(0, "Station database ID",                    "NUMERIC", DEF_MAXINT);
		infos[DBA_KEY_MOBILE	 ].set(0, "Station is mobile",                      "NUMERIC", DEF_MAXINT);
		infos[DBA_KEY_IDENT	 ].set(0, "Identifier of flight or ship",          "CCITTIA5", DEF_STRING(64));
		infos[DBA_KEY_LAT	 ].set(0, "Latitude",                                "DEGREE", 5, 0,   7,  -9000000, 25);
		infos[DBA_KEY_LON	 ].set(0, "Longitude",                               "DEGREE", 5, 0,   8, -18000000, 26);
		infos[DBA_KEY_LATMAX	 ].set(0, "Maximum latitude queried",                "DEGREE", 5, 0,   7,  -9000000, 25);
		infos[DBA_KEY_LATMIN	 ].set(0, "Minimum latitude queried",                "DEGREE", 5, 0,   7,  -9000000, 25);
		infos[DBA_KEY_LONMAX	 ].set(0, "Maximum longitude queried",               "DEGREE", 5, 0,   8, -18000000, 26);
		infos[DBA_KEY_LONMIN	 ].set(0, "Minimum longitude queried",               "DEGREE", 5, 0,   8, -18000000, 26);
		infos[DBA_KEY_YEAR	 ].set(0, "Year",                                      "YEAR", DEF_INT(4));
		infos[DBA_KEY_MONTH	 ].set(0, "Month",                                    "MONTH", DEF_INT(2));
		infos[DBA_KEY_DAY	 ].set(0, "Day",                                        "DAY", DEF_INT(2));
		infos[DBA_KEY_HOUR	 ].set(0, "Hour",                                      "HOUR", DEF_INT(2));
		infos[DBA_KEY_MIN	 ].set(0, "Minutes",                                 "MINUTE", DEF_INT(2));
		infos[DBA_KEY_SEC	 ].set(0, "Seconds",                                 "SECOND", DEF_INT(2));
		infos[DBA_KEY_YEARMAX	 ].set(0, "Maximum year queried",                      "YEAR", DEF_INT(4));
		infos[DBA_KEY_YEARMIN	 ].set(0, "Year or minimum year queried",              "YEAR", DEF_INT(4));
		infos[DBA_KEY_MONTHMAX	 ].set(0, "Maximum month queried",                    "MONTH", DEF_INT(2));
		infos[DBA_KEY_MONTHMIN	 ].set(0, "Minimum month queried",                    "MONTH", DEF_INT(2));
		infos[DBA_KEY_DAYMAX	 ].set(0, "Maximum day queried",                        "DAY", DEF_INT(2));
		infos[DBA_KEY_DAYMIN	 ].set(0, "Minimum day queried",                        "DAY", DEF_INT(2));
		infos[DBA_KEY_HOURMAX	 ].set(0, "Maximum hour queried",                      "HOUR", DEF_INT(2));
		infos[DBA_KEY_HOURMIN	 ].set(0, "Minumum hour queried",                      "HOUR", DEF_INT(2));
		infos[DBA_KEY_MINUMAX	 ].set(0, "Maxminum minutes queried",                "MINUTE", DEF_INT(2));
		infos[DBA_KEY_MINUMIN	 ].set(0, "Minimum minutes queried",                 "MINUTE", DEF_INT(2));
		infos[DBA_KEY_SECMAX	 ].set(0, "Maxminum seconds queried",                "SECOND", DEF_INT(2));
		infos[DBA_KEY_SECMIN	 ].set(0, "Minimum seconds queried",                 "SECOND", DEF_INT(2));
		infos[DBA_KEY_LEVELTYPE1 ].set(0, "Type of first level",                     "NUMBER", DEF_MAXINT);
		infos[DBA_KEY_L1	 ].set(0, "Level layer L1",                          "NUMBER", DEF_MAXINT);
		infos[DBA_KEY_LEVELTYPE2 ].set(0, "Type of second level",                    "NUMBER", DEF_MAXINT);
		infos[DBA_KEY_L2	 ].set(0, "Level layer L2",                          "NUMBER", DEF_MAXINT);
		infos[DBA_KEY_PINDICATOR ].set(0, "P indicator for time range",              "NUMBER", DEF_MAXINT);
		infos[DBA_KEY_P1	 ].set(0, "Time range P1",                           "SECOND", DEF_MAXINT);
		infos[DBA_KEY_P2	 ].set(0, "Time range P2",                           "SECOND", DEF_MAXINT);
		infos[DBA_KEY_VAR	 ].set(0, "Variable queried",                      "CCITTIA5", DEF_STRING(7));
		infos[DBA_KEY_VARLIST	 ].set(0, "List of variables to query",            "CCITTIA5", DEF_STRING(255));
		infos[DBA_KEY_CONTEXT_ID ].set(0, "Context ID of the variable",             "NUMERIC", DEF_MAXINT);
		infos[DBA_KEY_QUERY	 ].set(0, "Query behaviour modifier",              "CCITTIA5", DEF_STRING(255));
		infos[DBA_KEY_ANA_FILTER ].set(0, "Filter on anagraphical data",           "CCITTIA5", DEF_STRING(255));
		infos[DBA_KEY_DATA_FILTER].set(0, "Filter on data", 		           "CCITTIA5", DEF_STRING(255));
		infos[DBA_KEY_ATTR_FILTER].set(0, "Filter on data attributes",             "CCITTIA5", DEF_STRING(255));
		infos[DBA_KEY_LIMIT	 ].set(0, "Maximum number of results to return",     "NUMBER", DEF_MAXINT);
		infos[DBA_KEY_VAR_RELATED].set(0, "Variable related to attribute queried", "CCITTIA5", DEF_STRING(6));

		// Increment refcounts
		for (int i = 0; i < DBA_KEY_COUNT; ++i)
			infos[i].do_ref();
	}
};

static struct keyword_infos* infos = NULL;

}

static const char* keyword_names[] = {
	"priority",
	"priomax",
	"priomin",
	"rep_cod",
	"rep_memo",
	"ana_id",
	"mobile",
	"ident",
	"lat",
	"lon",
	"latmax",
	"latmin",
	"lonmax",
	"lonmin",
	"year",
	"month",
	"day",
	"hour",
	"min",
	"sec",
	"yearmax",
	"yearmin",
	"monthmax",
	"monthmin",
	"daymax",
	"daymin",
	"hourmax",
	"hourmin",
	"minumax",
	"minumin",
	"secmax",
	"secmin",
	"leveltype1",
	"l1",
	"leveltype2",
	"l2",
	"pindicator",
	"p1",
	"p2",
	"var",
	"varlist",
	"context_id",
	"query",
	"ana_filter",
	"data_filter",
	"attr_filter",
	"limit",
	"var_related",
};

const char* Record::keyword_name(dba_keyword key)
{
	return keyword_names[key];
}

Varinfo Record::keyword_info(dba_keyword keyword)
{
	if (infos == NULL) infos = new keyword_infos;
	return &(infos->infos[keyword]);
}

dba_keyword Record::keyword_byname(const char* tag)
{
	struct tagdef* res = RecordKeywords::find(tag, strlen(tag));
	if (res == NULL)
		return DBA_KEY_ERROR;
	else
		return res->index;
}

dba_keyword Record::keyword_byname_len(const char* tag, int len)
{
	struct tagdef* res = RecordKeywords::find(tag, len);
	if (res == NULL)
		return DBA_KEY_ERROR;
	else
		return res->index;
}

/*
dba_err dba_record_keyword_selftest()
{
	dba_keyword i, j;
	for (i = 0; i < DBA_KEY_COUNT; i++)
	{
		if (wordlist[i + 1].index != i)
			return dba_error_consistency("wordlist entry %d has index %d that does not match the position",
				i, wordlist[i + 1].index);
		j = dba_record_keyword_byname(wordlist[i + 1].tag);
		if (j != i)
			return dba_error_consistency("hashing of entry '%s' did not give expected index %d",
				wordlist[i + 1].tag, i);
	}
	return dba_error_ok();
}
*/

}

/* vim:set ts=4 sw=4: */
