/*
 * DB-ALLe - Archive for punctual meteorological data
 *
 * Copyright (C) 2005,2006  ARPA-SIM <urpsim@smr.arpa.emr.it>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 *
 * Author: Enrico Zini <enrico@enricozini.com>
 */

%define slot-name tag
%define lookup-function-name dba_record_keyword_in_word_set
%struct-type
%global-table
%compare-strncmp
/* Using %switch may be faster (remember to check when doing optimizations) */

%{
#include <string.h>
#include <limits.h>
#include "var.h"
#include "record.h"
%}

struct tagdef { const char* tag; dba_keyword index; };
%%
priority,    DBA_KEY_PRIORITY
priomax,     DBA_KEY_PRIOMAX
priomin,     DBA_KEY_PRIOMIN
rep_cod,     DBA_KEY_REP_COD
rep_memo,    DBA_KEY_REP_MEMO
ana_id,      DBA_KEY_ANA_ID
block,       DBA_KEY_BLOCK
station,     DBA_KEY_STATION
mobile,      DBA_KEY_MOBILE
ident,       DBA_KEY_IDENT
lat,         DBA_KEY_LAT
lon,         DBA_KEY_LON
latmax,      DBA_KEY_LATMAX
latmin,      DBA_KEY_LATMIN
lonmax,      DBA_KEY_LONMAX
lonmin,      DBA_KEY_LONMIN
datetime,    DBA_KEY_DATETIME
year,        DBA_KEY_YEAR
month,       DBA_KEY_MONTH
day,         DBA_KEY_DAY
hour,        DBA_KEY_HOUR
min,         DBA_KEY_MIN
sec,         DBA_KEY_SEC
yearmax,     DBA_KEY_YEARMAX
yearmin,     DBA_KEY_YEARMIN
monthmax,    DBA_KEY_MONTHMAX
monthmin,    DBA_KEY_MONTHMIN
daymax,      DBA_KEY_DAYMAX
daymin,      DBA_KEY_DAYMIN
hourmax,     DBA_KEY_HOURMAX
hourmin,     DBA_KEY_HOURMIN
minumax,     DBA_KEY_MINUMAX
minumin,     DBA_KEY_MINUMIN
secmax,      DBA_KEY_SECMAX
secmin,      DBA_KEY_SECMIN
leveltype,   DBA_KEY_LEVELTYPE
l1,          DBA_KEY_L1
l2,          DBA_KEY_L2
pindicator,  DBA_KEY_PINDICATOR
p1,          DBA_KEY_P1
p2,          DBA_KEY_P2
var,         DBA_KEY_VAR
varlist,     DBA_KEY_VARLIST
context_id,  DBA_KEY_CONTEXT_ID
query,		 DBA_KEY_QUERY
ana_filter,  DBA_KEY_ANA_FILTER
data_filter, DBA_KEY_DATA_FILTER
attr_filter, DBA_KEY_ATTR_FILTER
limit,		 DBA_KEY_LIMIT
var_related, DBA_KEY_VAR_RELATED
%%

#define DEF_STRING(len) 0, 0, len, 0, 0, 1, 0, 0, 0.0, 0.0
#define DEF_MAXINT 0, 0, 10, 0, 0, 0, INT_MIN, INT_MAX, (double)INT_MIN, (double)INT_MAX
#define LIM_8_5 -99999999, 99999999, -999.99999, 999.99999
#define LIM_4_0 -9999, 9999, -9999.0, 9999.0
#define LIM_2_0 -99, 99, -99.0, 99.0

static struct _dba_varinfo infos[] = {
	{ 0, "Priority of this type of report",          "NUMBER", DEF_MAXINT },
	{ 0, "Maximum priority of reports queried",      "NUMBER", DEF_MAXINT },
	{ 0, "Minimum priority of reports queried",      "NUMBER", DEF_MAXINT },
	{ 0, "Type of report",                           "NUMBER", DEF_MAXINT },
	{ 0, "Mnemonic alias for type of report",     "CHARACTER", DEF_STRING(20) },
	{ 0, "Pseudoana database ID",                   "NUMERIC", DEF_MAXINT },
	{ 0, "WMO block number",                        "NUMERIC", 0, 0,   2, 0, 0, 0, LIM_2_0 },
	{ 0, "WMO station number",                      "NUMERIC", DEF_MAXINT },
	{ 0, "Station is mobile",                       "NUMERIC", DEF_MAXINT },
	{ 0, "Identifier of flight or ship",          "CHARACTER", DEF_STRING(64) },
	{ 0, "Latitude",                                 "DEGREE", 5, 0,   8, 0, 0, 0, LIM_8_5 },
	{ 0, "Longitude",                                "DEGREE", 5, 0,   8, 0, 0, 0, LIM_8_5 },
	{ 0, "Maximum latitude queried",                 "DEGREE", 5, 0,   8, 0, 0, 0, LIM_8_5 },
	{ 0, "Minimum latitude queried",                 "DEGREE", 5, 0,   8, 0, 0, 0, LIM_8_5 },
	{ 0, "Maximum longitude queried",                "DEGREE", 5, 0,   8, 0, 0, 0, LIM_8_5 },
	{ 0, "Minimum longitude queried",                "DEGREE", 5, 0,   8, 0, 0, 0, LIM_8_5 },
	{ 0, "Date and time informations",            "CHARACTER", DEF_STRING(20) },
	{ 0, "Year",                                       "YEAR", 0, 0,   4, 0, 0, 0, LIM_4_0 },
	{ 0, "Month",                                     "MONTH", 0, 0,   2, 0, 0, 0, LIM_2_0 },
	{ 0, "Day",                                         "DAY", 0, 0,   2, 0, 0, 0, LIM_2_0 },
	{ 0, "Hour",                                       "HOUR", 0, 0,   2, 0, 0, 0, LIM_2_0 },
	{ 0, "Minutes",                                  "MINUTE", 0, 0,   2, 0, 0, 0, LIM_2_0 },
	{ 0, "Seconds",                                  "SECOND", 0, 0,   2, 0, 0, 0, LIM_2_0 },
	{ 0, "Maximum year queried",                       "YEAR", 0, 0,   4, 0, 0, 0, LIM_4_0 },
	{ 0, "Year or minimum year queried",               "YEAR", 0, 0,   4, 0, 0, 0, LIM_4_0 },
	{ 0, "Maximum month queried",                     "MONTH", 0, 0,   2, 0, 0, 0, LIM_2_0 },
	{ 0, "Minimum month queried",                     "MONTH", 0, 0,   2, 0, 0, 0, LIM_2_0 },
	{ 0, "Maximum day queried",                         "DAY", 0, 0,   2, 0, 0, 0, LIM_2_0 },
	{ 0, "Minimum day queried",                         "DAY", 0, 0,   2, 0, 0, 0, LIM_2_0 },
	{ 0, "Maximum hour queried",                       "HOUR", 0, 0,   2, 0, 0, 0, LIM_2_0 },
	{ 0, "Minumum hour queried",                       "HOUR", 0, 0,   2, 0, 0, 0, LIM_2_0 },
	{ 0, "Maxminum minutes queried",                 "MINUTE", 0, 0,   2, 0, 0, 0, LIM_2_0 },
	{ 0, "Minimum minutes queried",                  "MINUTE", 0, 0,   2, 0, 0, 0, LIM_2_0 },
	{ 0, "Maxminum seconds queried",                 "SECOND", 0, 0,   2, 0, 0, 0, LIM_2_0 },
	{ 0, "Minimum seconds queried",                  "SECOND", 0, 0,   2, 0, 0, 0, LIM_2_0 },
	{ 0, "Level type",                               "NUMBER", DEF_MAXINT },
	{ 0, "Level layer L1",                           "NUMBER", DEF_MAXINT },
	{ 0, "Level layer L2",                           "NUMBER", DEF_MAXINT },
	{ 0, "P indicator for time range",               "NUMBER", DEF_MAXINT },
	{ 0, "Time range P1",                            "SECOND", DEF_MAXINT },
	{ 0, "Time range P2",                            "SECOND", DEF_MAXINT },
	{ 0, "Variable queried",                      "CHARACTER", DEF_STRING(7) },
	{ 0, "List of variables to query",            "CHARACTER", DEF_STRING(255) },
	{ 0, "ID of the variable in the database",      "NUMERIC", DEF_MAXINT },
	{ 0, "Query behaviour modifier",              "CHARACTER", DEF_STRING(255) },
	{ 0, "Filter on anagraphical data",           "CHARACTER", DEF_STRING(255) },
	{ 0, "Filter on data", 			              "CHARACTER", DEF_STRING(255) },
	{ 0, "Filter on data attributes",             "CHARACTER", DEF_STRING(255) },
	{ 0, "Maximum number of results to return",      "NUMBER", DEF_MAXINT },
	{ 0, "Variable related to attribute queried", "CHARACTER", DEF_STRING(6) },
};

/* End of table definitions */

dba_varinfo dba_record_keyword_byindex(int index)
{
	return &(infos[index]);
}

dba_keyword dba_record_keyword_byname(const char* tag)
{
	struct tagdef* res = dba_record_keyword_in_word_set(tag, strlen(tag));
	if (res == NULL)
		return DBA_KEY_ERROR;
	else
		return res->index;
}

dba_keyword dba_record_keyword_byname_len(const char* tag, int len)
{
	struct tagdef* res = dba_record_keyword_in_word_set(tag, len);
	if (res == NULL)
		return DBA_KEY_ERROR;
	else
		return res->index;
}

dba_varinfo dba_record_keyword(const char* tag, int* index)
{
	struct tagdef* res = dba_record_keyword_in_word_set(tag, strlen(tag));
	if (res == NULL)
		return NULL;
	else
	{
		*index = res->index;
		return dba_record_keyword_byindex(*index);
	}
}

/*
dba_err dba_record_keyword_selftest()
{
	dba_keyword i, j;
	for (i = 0; i < DBA_KEY_COUNT; i++)
	{
		if (wordlist[i + 1].index != i)
			return dba_error_consistency("wordlist entry %d has index %d that does not match the position",
				i, wordlist[i + 1].index);
		j = dba_record_keyword_byname(wordlist[i + 1].tag);
		if (j != i)
			return dba_error_consistency("hashing of entry '%s' did not give expected index %d",
				wordlist[i + 1].tag, i);
	}
	return dba_error_ok();
}
*/

/* vim:set ts=4 sw=4: */
