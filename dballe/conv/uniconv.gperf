%define slot-name tag
%define lookup-function-name get_uniconv
%struct-type
/* Using %switch may be faster (remember to check when doing optimizations) */

%{
#include <stdio.h>
#include <string.h>
#include <dballe/conv/conv.h>
%}

/* Note: the _ref member of info is always set to 1 to avoid the structure
 * being deallocated from dba_varinfo_delete */
struct uniconv { const char* tag; double mul; double add; };
%%
"K->C",					1,	 -273.16
"C->K",					1,	  273.16
"K->C/10",			   10,	-2731.6
"C/10->K",				0.1,  273.16
"C->C/10",			   10,		0
"C/10->C",				0.1,	0
"YEARS->YEAR",			1,   	0
"YEAR->YEARS",			1,   	0
"MONTHS->MONTH",		1,   	0
"MONTH->MONTHS",		1,   	0
"DAYS->DAY",			1,   	0
"DAY->DAYS",			1,   	0
"HOURS->HOUR",			1,   	0
"HOUR->HOURS",			1,   	0
"MINUTES->MINUTE",		1,   	0
"MINUTE->MINUTES",		1,   	0
"SECONDS->SECOND",		1,   	0
"SECOND->SECONDS",		1,   	0
"SECOND->S",			1,		0
"S->SECOND",			1,		0
"sec->S",				1,		0
"S->sec",				1,		0
"G/G->KG/KG",			1,   	0
"KG/KG->G/G",			1,  	0
"G/M**3->KG/M**3",	    0.001,	0
"KG/M**3->G/M**3",	 1000,		0
"PA->KPA",				0.001,	0
"KPA->PA",			 1000,		0
"m**(2/3)/S->M**(2/3)/S", 1,	0
"M**(2/3)/S->m**(2/3)/S", 1,	0
"M->MM",			 1000,		0
"MM->M",			 	0.001,	0
"M->cm",			  100,		0
"cm->M",			 	0.01,	0
"%->PERCENT",			1,		0
"PERCENT->%",			1,		0
"M->FT",			    3.2808,	0
"FT->M",			    0.3048,	0
"DEGREE**2->DEGREE2",	1,		0
"DEGREE2->DEGREE**2",	1,		0
"KG/M**2->KGM-2",		1,		0
"KGM-2->KG/M**2",		1,		0
"J/M**2->JM-2",			1,		0
"JM-2->J/M**2",			1,		0
"cal/cm**2->J/M**2",	41840,	0
"J/M**2->cal/cm**2",	0.000023901, 0
"Bq/L->BQ L-1",			1,		0
"BQ L-1->Bq/L",			1,		0
"DOBSON->DU",			1,		0
"DU->DOBSON",			1,		0
"PA->NBAR",				0.0001,	0		
"NBAR->PA",			10000,		0
"LOG(1/M**2)->LOG (M-2)", 1,	0
"LOG (M-2)->LOG(1/M**2)", 1,	0
"DEGREE TRUE->gsess",	1,		0
"gsess->DEGREE TRUE",	1,		0
"m/s/10->M/S",			0.1,	0
"M/S->m/s/10",		   10,		0
"nodi->M/S",			0.51446,	0
"M/S->nodi",			1.9438,		0
"PA->mBar",				0.01,	0
"mBar->PA",	 	      100,		0
"PA->Bar",				0.00001,	0
"Bar->PA",	 	   100000,		0
"m->M",					1,		0
"M->m",					1,		0
"hm->M",			  100,		0
"M->hm",				0.01,	0
"mm->M",				0.001,	0
"M->mm",			 1000,		0
"1/8->%",			   12.5,	0
"%->1/8",			  	0.08,	0
"mm->KG/M**2",			1,		0
"KG/M**2->mm",			1,		0
%%

int dba_convert_units_allowed(const char* from, const char* to)
{
	if (strcmp(from, to) == 0
	    || strncmp(from, "CODE TABLE", 10) == 0
		|| strncmp(to, "CODE TABLE", 10) == 0
	    || strncmp(from, "FLAG TABLE", 10) == 0
		|| strncmp(to, "FLAG TABLE", 10) == 0)
	{
		return 1;
	} else {
		char query[50];
		int len = snprintf(query, 48, "%s->%s", from, to);
		struct uniconv* info = get_uniconv(query, len);
		return info != NULL;
	}
}

dba_err dba_convert_units(const char* from, const char* to, double val, double* res)
{
	if (strcmp(from, to) == 0
	    || strncmp(from, "CODE TABLE", 10) == 0
		|| strncmp(to, "CODE TABLE", 10) == 0
	    || strncmp(from, "FLAG TABLE", 10) == 0
		|| strncmp(to, "FLAG TABLE", 10) == 0)
	{
		*res = val;
		return dba_error_ok();

	} else {
		char query[50];
		int len = snprintf(query, 48, "%s->%s", from, to);
		struct uniconv* info = get_uniconv(query, len);
		if (info == NULL)
			return dba_error_notfound("looking for conversion from \"%s\" to \"%s\"", from, to);
		else
		{
			*res = val * info->mul + info->add;
			return dba_error_ok();
		}
	}
}

dba_err dba_convert_units_get_mul(const char* from, const char* to, double* mul)
{
	if (strcmp(from, to) == 0
	    || strncmp(from, "CODE TABLE", 10) == 0
		|| strncmp(to, "CODE TABLE", 10) == 0
	    || strncmp(from, "FLAG TABLE", 10) == 0
		|| strncmp(to, "FLAG TABLE", 10) == 0)
	{
		*mul = 1;
		return dba_error_ok();
	} else {
		char query[50];
		int len = snprintf(query, 48, "%s->%s", from, to);
		struct uniconv* info = get_uniconv(query, len);
		if (info == NULL)
			return dba_error_notfound("looking for conversion from \"%s\" to \"%s\"", from, to);
		else
		{
			*mul = info->mul;
			return dba_error_ok();
		}
	}
}

/* vim:set ts=4 sw=4: */
