#!/usr/bin/python3

"""
Build C++ code for accessing Msg contents by shortcut.
"""

import argparse
import sys
import re
import logging

log = logging.getLogger("mklookup")


class Fail(Exception):
    pass


class VC:
    def __init__(self, name):
        m = re.match(r"B(\d\d)(\d\d\d)", name)
        if not m:
            raise "Invalid B local"
        self.x = int(m.group(1))
        self.y = int(m.group(2))

    def __str__(self):
        return "B%02d%03d" % (self.x, self.y)

    def __lt__(self, o):
        return (self.x, self.y) < (o.x, o.y)


class Var:
    def __init__(self, line):
        def cleanint(x):
            if x == '-':
                return "MISSING_INT"
            return str(int(x))

        vals = re.split(r"\s*,\s*", line[:-1].strip())

        self.name, self.type = vals[0:2]
        self.b = VC(vals[2])
        self.letr = [cleanint(x) for x in vals[3:-1]]
        self.desc = vals[-1]

    def __str__(self):
        return ", ".join([self.name, str(self.b),
                          ":".join([str(x) for x in self.letr[0:4]]),
                          ":".join([str(x) for x in self.letr[4:]]),
                          self.desc])

    def __lt__(self, o):
        return (self.letr, self.b) < (o.letr, o.b)


class Vars:
    def __init__(self, file):
        self.vars = [Var(line) for line in file if not re.match(r"^\s*(?:#.+)?$", line)]
        self.vars.sort()

    def print_vars_h(self, file):
        print("""#ifndef DBA_MSG_VARS_H
#define DBA_MSG_VARS_H

/** @file
 * @ingroup msg
 * Shortcut IDs and functions to quickly refer to commonly used values inside a
 * dballe::msg::Msg.
 *
 * The shortcuts are defined in the file vars.csv, which maps a name to the tuple
 * (preferred C type, BLocal, Level type, L1, L2, P indicator, P1, P2).  The file
 * vars.csv is used to generate code (vars.h and vars.c) that provides a set of
 * getters and setters for every named value.
 */

#include <wreport/varinfo.h>

namespace dballe {

/**
 * Full data corresponding to a shortcut ID
 */
struct MsgVarShortcut {
    /** Variable description code */
    wreport::Varcode code;
    /** Type of the first level.  See @ref level_table. */
    int ltype1;
    /** L1 value of the level.  See @ref level_table. */
    int l1;
    /** Type of the second level.  See @ref level_table. */
    int ltype2;
    /** L2 value of the level.  See @ref level_table. */
    int l2;
    /** Time range type indicator.  See @ref trange_table. */
    int pind;
    /** Time range P1 indicator.  See @ref trange_table. */
    int p1;
    /** Time range P2 indicator.  See @ref trange_table. */
    int p2;
};

/** Array with all the full expansions of the shortcut IDs, indexed by shortcut
  * ID
  */
extern struct MsgVarShortcut shortcutTable[];

/** Resolve a var name to a var ID */
int resolve_var(const char* name);

/** Resolve a var name to a var ID, avoiding to compute the length of name */
int resolve_var_substring(const char* name, int len);
""", file=file)

        for i, v in enumerate(self.vars):
            print("/** %s */" % v.desc, file=file)
            print("#define DBA_MSG_%s %d" % (v.name, i), file=file)
        print("/** Number of items in dba_msg_vartable */", file=file)
        print("#define DBA_MSG_VARTABLE_SIZE %d" % i, file=file)
        print("""
}

#endif
""", file=file)

    def print_extravars_h(self, file):
        types = {"int": "int", "num": "double", "str": "const char*"}
        ftypes = {"int": "i", "num": "d", "str": "c"}
        for v in self.vars:
            print("""
    /** Set the value of "{desc}" from a variable of type {type} */
    inline void set_{name}({type} val, int conf=-1) {{ set{ftype}(Level({level}), Trange({trange}), WR_VAR(0, {vx}, {vy}), val, conf); }}
    /** Set the value of "{desc}" from a wreport::Var */
    inline void set_{name}_var(const wreport::Var& val) {{ set(Level({level}), Trange({trange}), WR_VAR(0, {vx}, {vy}), val); }}
    /** Get the "{desc}" physical value stored in the message */
    inline const wreport::Var* get_{name}_var() const {{ return get(DBA_MSG_{NAME}); }}
    """ .format(
                name=v.name.lower(),
                desc=v.desc,
                type=types[v.type],
                ftype=ftypes[v.type],
                vx=v.b.x, vy=v.b.y,
                level=", ".join(v.letr[:4]),
                trange=", ".join(v.letr[4:]),
                NAME=v.name,
            ), file=file)

    def print_vars_gperf(self, file):
        print("""
%define slot-name name
%define class-name MsgVarLookup
%define lookup-function-name find
%struct-type
%language=C++
%global-table
%compare-strncmp
/* Using %switch may be faster (remember to check when doing optimizations) */

%{
#include <dballe/types.h>
#include <dballe/msg/vars.h>
#include <string.h>

namespace dballe {
%}

struct msgvardef { const char* name; int var; };
%%""", file=file)
        for v in self.vars:
            print("{}, DBA_MSG_{}".format(v.name.lower(), v.name), file=file)
        print("""%%

int resolve_var(const char* name)
{
    struct msgvardef* res = MsgVarLookup::find(name, strlen(name));
        if (res == NULL)
                return -1;
        else
                return res->var;
}

int resolve_var_substring(const char* name, int len)
{
    struct msgvardef* res = MsgVarLookup::find(name, len);
        if (res == NULL)
                return -1;
        else
                return res->var;
}

""", file=file)

        print("struct MsgVarShortcut shortcutTable[] = {", file=file)
        for v in self.vars:
            print(" { WR_VAR(0, %d, %d), %s, %s, %s, %s, %s, %s, %s }," % tuple([v.b.x, v.b.y] + v.letr), file=file)
        print("};", file=file)
        print("}", file=file)


def main():
    parser = argparse.ArgumentParser(
            description="build C++ code for named import/export of variables")
    parser.add_argument("--verbose", "-v", action="store_true", help="verbose output")
    parser.add_argument("--debug", action="store_true", help="debug output")
    parser.add_argument("output", nargs="?", help="output file type")
    args = parser.parse_args()

    log_format = "%(asctime)-15s %(levelname)s %(message)s"
    level = logging.WARN
    if args.debug:
        level = logging.DEBUG
    elif args.verbose:
        level = logging.INFO
    logging.basicConfig(level=level, stream=sys.stderr, format=log_format)

    vars = Vars(sys.stdin)
    if args.output == "vars.h":
        vars.print_vars_h(sys.stdout)
    elif args.output == "msg-extravars.h":
        vars.print_extravars_h(sys.stdout)
    elif args.output == "vars.gperf":
        vars.print_vars_gperf(sys.stdout)
    else:
        raise Fail("Output type {} is not recognised".format(args.output))


if __name__ == "__main__":
    try:
        main()
    except Fail as e:
        log.error("%s", e)
        sys.exit(1)
