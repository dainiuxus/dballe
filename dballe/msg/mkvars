#!/usr/bin/python

import sys, re, os

class VC:
    def __init__(self, name):
        m = re.match(r"B(\d\d)(\d\d\d)", name)
        if not m:
            raise "Invalid B local"
        self.x = int(m.group(1))
        self.y = int(m.group(2))

    def __str__(self):
        return "B%02d%03d" % (self.x, self.y)

    def __cmp__(self, o):
        c = self.x.__cmp__(o.x)
        if c != 0: return c
        return self.y.__cmp__(o.y)

class Var:
    def __init__(self, line):
        def cleanint(x):
           if x == '-': return 0
           return int(x)

        vals = re.split(r"\s*,\s*", line[:-1].strip())

        self.name, self.type = vals[0:2]
        self.b = VC(vals[2])
        self.letr = [cleanint(x) for x in vals[3:-1]]
        self.desc = vals[-1]

    def __str__(self):
        return ", ".join([self.name, str(self.b),
                        ":".join([str(x) for x in self.letr[0:4]]),
                        ":".join([str(x) for x in self.letr[4:]]),
                        self.desc])

    def __cmp__(self, o):
        for i in range(len(self.letr)):
            c = self.letr[i].__cmp__(o.letr[i])
            if c != 0: return c
        return self.b.__cmp__(o.b)

vars = [Var(line) for line in sys.stdin if not re.match(r"^\s*(?:#.+)?$", line)]
vars.sort()

fh = open("vars.h", "w")
print >>fh, """#ifndef DBA_MSG_VARS_H
#define DBA_MSG_VARS_H

#ifdef  __cplusplus
extern "C" {
#endif

/** @file
 * @ingroup msg
 * Shortcut IDs and functions to quickly refer to commonly used values inside a
 * ::dba_msg.
 *
 * The shortcuts are defined in the file vars.csv, which maps a name to the tuple
 * (preferred C type, BLocal, Level type, L1, L2, P indicator, P1, P2).  The file
 * vars.csv is used to generate code (vars.h and vars.c) that provides a set of
 * getters and setters for every named value.
 */

#include <dballe/msg/msg.h>

/**
 * Full data corresponding to a shortcut ID
 */
struct _dba_msg_var {
    /** Variable description code */
    dba_varcode code;
    /** Type of the first level.  See @ref level_table. */
    int ltype1;
    /** L1 value of the level.  See @ref level_table. */
    int l1;
    /** Type of the second level.  See @ref level_table. */
    int ltype2;
    /** L2 value of the level.  See @ref level_table. */
    int l2;
    /** Time range type indicator.  See @ref trange_table. */
    int pind;
    /** Time range P1 indicator.  See @ref trange_table. */
    int p1;
    /** Time range P2 indicator.  See @ref trange_table. */
    int p2;
};
/** @copydoc _dba_msg_var */
typedef struct _dba_msg_var* dba_msg_var;

/** Array with all the full expansions of the shortcut IDs, indexed by shortcut
  * ID
  */
extern struct _dba_msg_var dba_msg_vartable[];

/** Resolve a var name to a var ID */
int dba_msg_resolve_var(const char* name);

/** Resolve a var name to a var ID, avoiding to compute the length of name */
int dba_msg_resolve_var_substring(const char* name, int len);
"""

for i, v in enumerate(vars):
    print >>fh, "/** %s */" % v.desc
    print >>fh, "#define DBA_MSG_%s %d" % (v.name, i)
print >>fh, "/** Number of items in dba_msg_vartable */";
print >>fh, "#define DBA_MSG_VARTABLE_SIZE %d" % i;

types = dict(int = 'int', num = 'double', str = 'const char*')
ftypes = dict(int = 'i', num = 'd', str = 'c')
for v in vars:
    print >>fh, "/** Set the value of \"%s\" from a variable of type %s */" % (v.desc, types[v.type])
    print >>fh, "inline static dba_err dba_msg_set_%s(dba_msg msg, %s val, int conf) " % (v.name.lower(), types[v.type]),
    #print >>sys.stderr, v
    #print >>sys.stderr, "--", [ftypes[v.type], v.b.x, v.b.y] + v.letr;
    print >>fh, "{ return dba_msg_set%s(msg, DBA_VAR(0, %d, %d), val, conf, %d, %d, %d, %d, %d, %d, %d); }" % \
        tuple([ftypes[v.type], v.b.x, v.b.y] + v.letr);

    print >>fh, "/** Set the value of \"%s\" from a ::dba_var */" % v.desc;
    print >>fh, "inline static dba_err dba_msg_set_%s_var(dba_msg msg, dba_var val) " % v.name.lower(),
    print >>fh, "{ return dba_msg_set(msg, val, DBA_VAR(0, %d, %d), %d, %d, %d, %d, %d, %d, %d); }" % \
            tuple([v.b.x, v.b.y] + v.letr)

    print >>fh, "/** Get the \"%s\" physical value stored in the message */" % v.desc;
    print >>fh, "inline static dba_var dba_msg_get_%s_var(dba_msg msg) " % v.name.lower();
    print >>fh, "{ dba_msg_datum d = dba_msg_find_by_id(msg, DBA_MSG_%s); return d == NULL ? NULL : d->var; }" % \
        v.name;

print >>fh, """
#ifdef  __cplusplus
}
#endif

#endif
"""
fh.close()

fc = open("vars.gperf", "w")
print >>fc, """
%define slot-name name
%define lookup-function-name dba_msg_resolve_var_in_word_set
%struct-type
%global-table
%compare-strncmp
/* Using %switch may be faster (remember to check when doing optimizations) */

%{
#include <dballe/msg/vars.h>
#include <string.h>
%}

struct msgvardef { const char* name; int var; };
%%"""
for v in vars:
    print >>fc, "%s, DBA_MSG_%s" % (v.name.lower(), v.name)
print >>fc, """%%

int dba_msg_resolve_var(const char* name)
{
	struct msgvardef* res = dba_msg_resolve_var_in_word_set(name, strlen(name));
	if (res == NULL)
		return -1;
	else
		return res->var;
}

int dba_msg_resolve_var_substring(const char* name, int len)
{
	struct msgvardef* res = dba_msg_resolve_var_in_word_set(name, len);
	if (res == NULL)
		return -1;
	else
		return res->var;
}
"""

print >>fc, "struct _dba_msg_var dba_msg_vartable[] = {"
for v in vars:
    print >>fc, " { DBA_VAR(0, %d, %d), %d, %d, %d, %d, %d, %d, %d }," % tuple([v.b.x, v.b.y] + v.letr)
print >>fc, "};"

fc.close()

sys.exit()
