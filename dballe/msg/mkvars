#!/usr/bin/python

"""
Build C++ code for accessing Msg contents by shortcut.
"""

from __future__ import (print_function, absolute_import, division, unicode_literals)
import sys
import re
import os

DESTDIR = "."
if len(sys.argv) > 1:
    DESTDIR = sys.argv[1]


class VC:
    def __init__(self, name):
        m = re.match(r"B(\d\d)(\d\d\d)", name)
        if not m:
            raise "Invalid B local"
        self.x = int(m.group(1))
        self.y = int(m.group(2))

    def __str__(self):
        return "B%02d%03d" % (self.x, self.y)

    def __cmp__(self, o):
        c = self.x.__cmp__(o.x)
        if c != 0:
            return c
        return self.y.__cmp__(o.y)


class Var:
    def __init__(self, line):
        def cleanint(x):
            if x == '-':
                return "MISSING_INT"
            return str(int(x))

        vals = re.split(r"\s*,\s*", line[:-1].strip())

        self.name, self.type = vals[0:2]
        self.b = VC(vals[2])
        self.letr = [cleanint(x) for x in vals[3:-1]]
        self.desc = vals[-1]

    def __str__(self):
        return ", ".join([self.name, str(self.b),
                          ":".join([str(x) for x in self.letr[0:4]]),
                          ":".join([str(x) for x in self.letr[4:]]),
                          self.desc])

    def __cmp__(self, o):
        def cmpval(a, b):
            if a == "MISSING_INT" and b == "MISSING_INT":
                return 0
            if a == "MISSING_INT":
                return -1
            if b == "MISSING_INT":
                return 1
            return int(b) - int(a)
        for i in range(len(self.letr)):
            c = cmpval(self.letr[i], o.letr[i])
            if c != 0:
                return c
        return self.b.__cmp__(o.b)


vars = [Var(line) for line in sys.stdin if not re.match(r"^\s*(?:#.+)?$", line)]
vars.sort()

with open(os.path.join(DESTDIR, "vars.h"), "wt") as fh:
    print("""#ifndef DBA_MSG_VARS_H
#define DBA_MSG_VARS_H

/** @file
 * @ingroup msg
 * Shortcut IDs and functions to quickly refer to commonly used values inside a
 * dballe::msg::Msg.
 *
 * The shortcuts are defined in the file vars.csv, which maps a name to the tuple
 * (preferred C type, BLocal, Level type, L1, L2, P indicator, P1, P2).  The file
 * vars.csv is used to generate code (vars.h and vars.c) that provides a set of
 * getters and setters for every named value.
 */

#include <wreport/varinfo.h>

namespace dballe {

/**
 * Full data corresponding to a shortcut ID
 */
struct MsgVarShortcut {
    /** Variable description code */
    wreport::Varcode code;
    /** Type of the first level.  See @ref level_table. */
    int ltype1;
    /** L1 value of the level.  See @ref level_table. */
    int l1;
    /** Type of the second level.  See @ref level_table. */
    int ltype2;
    /** L2 value of the level.  See @ref level_table. */
    int l2;
    /** Time range type indicator.  See @ref trange_table. */
    int pind;
    /** Time range P1 indicator.  See @ref trange_table. */
    int p1;
    /** Time range P2 indicator.  See @ref trange_table. */
    int p2;
};

/** Array with all the full expansions of the shortcut IDs, indexed by shortcut
  * ID
  */
extern struct MsgVarShortcut shortcutTable[];

/** Resolve a var name to a var ID */
int resolve_var(const char* name);

/** Resolve a var name to a var ID, avoiding to compute the length of name */
int resolve_var_substring(const char* name, int len);
""", file=fh)

    for i, v in enumerate(vars):
        print("/** %s */" % v.desc, file=fh)
        print("#define DBA_MSG_%s %d" % (v.name, i), file=fh)
    print("/** Number of items in dba_msg_vartable */", file=fh)
    print("#define DBA_MSG_VARTABLE_SIZE %d" % i, file=fh)
    print("""
}

#endif
""", file=fh)

with open(os.path.join(DESTDIR, "msg-extravars.h"), "wt") as fh:
    types = {"int": "int", "num": "double", "str": "const char*"}
    ftypes = {"int": "i", "num": "d", "str": "c"}
    for v in vars:
        print("""
/** Set the value of "{desc}" from a variable of type {type} */
inline void set_{name}({type} val, int conf=-1) {{ set{ftype}(WR_VAR(0, {vx}, {vy}), val, conf, Level({level}), Trange({trange})); }}
/** Set the value of "{desc}" from a wreport::Var */
inline void set_{name}_var(const wreport::Var& val) {{ set(val, WR_VAR(0, {vx}, {vy}), Level({level}), Trange({trange})); }}
/** Get the "{desc}" physical value stored in the message */
inline const wreport::Var* get_{name}_var() const {{ return find_by_id(DBA_MSG_{NAME}); }}
""" .format(
            name=v.name.lower(),
            desc=v.desc,
            type=types[v.type],
            ftype=ftypes[v.type],
            vx=v.b.x, vy=v.b.y,
            level=", ".join(v.letr[:4]),
            trange=", ".join(v.letr[4:]),
            NAME=v.name,
        ), file=fh)


with open(os.path.join(DESTDIR, "context-extravars.h"), "wt") as fh:
    for v in vars:
        print("""
/** Set the value of "{desc}" from a variable of type {type} */
inline void set_{name}({type} val) {{ set{ftype}(WR_VAR(0, {vx}, {vy}), val); }}
/** Get the "{desc}" physical value stored in the message */
inline const wreport::Var* get_{name}() const {{ return find(WR_VAR(0, {vx}, {vy})); }}
""" .format(
            name=v.name.lower(),
            desc=v.desc,
            type=types[v.type],
            ftype=ftypes[v.type],
            vx=v.b.x, vy=v.b.y,
        ), file=fh)


with open(os.path.join(DESTDIR, "vars.gperf"), "wt") as fc:
    print("""
%define slot-name name
%define class-name MsgVarLookup
%define lookup-function-name find
%struct-type
%language=C++
%global-table
%compare-strncmp
/* Using %switch may be faster (remember to check when doing optimizations) */

%{
#include <dballe/types.h>
#include <dballe/msg/vars.h>
#include <string.h>

namespace dballe {
%}

struct msgvardef { const char* name; int var; };
%%""", file=fc)
    for v in vars:
        print("{}, DBA_MSG_{}".format(v.name.lower(), v.name), file=fc)
    print("""%%

int resolve_var(const char* name)
{
    struct msgvardef* res = MsgVarLookup::find(name, strlen(name));
        if (res == NULL)
                return -1;
        else
                return res->var;
}

int resolve_var_substring(const char* name, int len)
{
    struct msgvardef* res = MsgVarLookup::find(name, len);
        if (res == NULL)
                return -1;
        else
                return res->var;
}

""", file=fc)

    print("struct MsgVarShortcut shortcutTable[] = {", file=fc)
    for v in vars:
        print(" { WR_VAR(0, %d, %d), %s, %s, %s, %s, %s, %s, %s }," % tuple([v.b.x, v.b.y] + v.letr), file=fc)
    print("};", file=fc)
    print("} // namespace dballe", file=fc)
