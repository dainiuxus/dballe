/*
 * dballe/db - Archive for point-based meteorological data
 *
 * Copyright (C) 2005--2010  ARPA-SIM <urpsim@smr.arpa.emr.it>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 *
 * Author: Enrico Zini <enrico@enricozini.com>
 */

#ifndef DBA_DB_H
#define DBA_DB_H

#if 0
#include <dballe/core/record.h>
#include <dballe/core/var.h>
#include <dballe/db/cursor.h>
#include <sqltypes.h>
#endif

#include <dballe/db/odbcworkarounds.h>
#include <string>

/** @file
 * @ingroup db
 *
 * Functions used to connect to DB-All.e and insert, query and delete data.
 */

namespace dballe {
struct Record;

namespace db {
struct Connection;
struct Statement;
struct Sequence;
struct Repinfo;
struct Station;
struct Context;
struct Data;
}

/**
 * DB-ALLe database connection
 */
class DB
{
public:
	/** ODBC database connection */
	db::Connection* conn;

protected:
	/**
	 * Accessors for the various parts of the database.
	 *
	 * @warning Before using these 5 pointers, ensure they are initialised
	 * using one of the dba_db_need_* functions
	 * @{
	 */
	/** Report information */
	struct db::Repinfo* m_repinfo;
	/** Station information */
	struct db::Station* m_station;
	/** Variable context */
	struct db::Context* m_context;
	/** Variable data */
	struct db::Data* m_data;
#if 0
	/** Variable attributes */
	struct _dba_db_attr* attr;
	/** @} */

	/** Precompiled BEGIN SQL statement */
	//db::Statement* stm_begin;
#endif
	/** Precompiled LAST_INSERT_ID (or equivalent) SQL statement */
	db::Statement* stm_last_insert_id;
	/** ID of the last autogenerated primary key */
	DBALLE_SQL_C_SINT_TYPE m_last_insert_id;

	/**
	 * Sequence accessors.
	 *
	 * They are NULL for databases such as MySQL that do not use sequences.
	 * @{
	 */
	/** Station ID sequence */
	db::Sequence* seq_station;
	/** Context ID sequence */
	db::Sequence* seq_context;
        /** @} */

	void init_after_connect();

	/**
	 * Run a one-off SQL query
	 */
	void run_sql(const char* query);

	/**
	 * Delete a table in the database if it exists, otherwise do nothing.
	 */
	void drop_table_if_exists(const char* name);

	/**
	 * Delete a sequence in the database if it exists, otherwise do nothing.
	 */
	void drop_sequence_if_exists(const char* name);

public:
	DB();
	~DB();

	/**
	 * Start a session with DB-All.e
	 *
	 * @param dsn
	 *   The ODBC DSN of the database to use
	 * @param user
	 *   The user name to use to connect to the DSN
	 * @param password
	 *   The password to use to connect to the DSN.  To specify an empty password,
	 *   pass "" or NULL
	 * @retval db
	 *   The dba_db handle returned by the function
	 * @return
	 *   The error indicator for the function (See @ref error.h)
	 */
	void connect(const char* dsn, const char* user, const char* password);

	/**
	 * Start a session with DB-All.e
	 *
	 * @param config
	 *   The string with the configuration to use to start the connection. This is
	 *   passed as is to SQLDriverConnect, so see ODBC documentation for its
	 *   format.
	 */
	void connect_generic(const char* config);

	/**
	 * Create from a SQLite file pathname
	 * 
	 * @param pathname
	 *   The pathname to a SQLite file
	 */
	void connect_from_file(const char* pathname);

	/**
	 * Create from an url-like specification, that can be:
	 * 
	 * @l sqlite:[//]foo.sqlite
	 * @l odbc://[user[:pass]@]dsn
	 * @l test:[//]
	 *
	 * @param url
	 *   The url-like connection descriptor
	 */
	void connect_from_url(const char* url);

	/**
	 * Start a test session with DB-All.e
	 *
	 * Take information from the environment (@see dba_db_create_from_env) and
	 * default to ./test.sqlite if nothing is specified.
	 */
	void connect_test();

	/**
	 * Return TRUE if the string looks like a DB URL
	 *
	 * @param str
	 *   The string to test
	 * @return
	 *   true if it looks like a URL, else false
	 */
	static bool is_url(const char* str);

	/// Access the repinfo table
	db::Repinfo& repinfo();

	/// Access the station table
	db::Station& station();

	/// Access the context table
	db::Context& context();

	/// Access the data table
	db::Data& data();

	/**
	 * Reset the database, removing all existing DBALLE tables and re-creating them
	 * empty.
	 *
	 * @param repinfo_file
	 *   The name of the CSV file with the report type information data to load.
	 *   The file is in CSV format with 6 columns: report code, mnemonic id,
	 *   description, priority, descriptor, table A category.
	 *   If repinfo_file is NULL, then the default of /etc/dballe/repinfo.csv is
	 *   used.
	 */
	void reset(const char* repinfo_file = 0);

	/**
	 * Delete all the DB-ALLe tables from the database.
	 */
	void delete_tables();

	/**
	 * Update the repinfo table in the database, with the data found in the given
	 * file.
	 *
	 * @param repinfo_file
	 *   The name of the CSV file with the report type information data to load.
	 *   The file is in CSV format with 6 columns: report code, mnemonic id,
	 *   description, priority, descriptor, table A category.
	 *   If repinfo_file is NULL, then the default of /etc/dballe/repinfo.csv is
	 *   used.
	 * @retval added
	 *   The number of repinfo entryes that have been added
	 * @retval deleted
	 *   The number of repinfo entryes that have been deleted
	 * @retval updated
	 *   The number of repinfo entryes that have been updated
	 */
	void update_repinfo(const char* repinfo_file, int* added, int* deleted, int* updated);

	/**
	 * Get the report code from a report mnemonic
	 */
	int rep_cod_from_memo(const char* memo);

	/**
	 * Get the report mnemonic from a report code
	 */
	const std::string& rep_memo_from_cod(int rep_cod);

	/**
	 * Verify that a rep_cod is supported by the database
	 *
	 * @param rep_cod
	 *   The report code to verify
	 * @returns
	 *   true if the report code is supported, false if not
	 */
	bool check_rep_cod(int rep_cod);

	/**
	 * Return the ID of the last inserted station
	 */
	int last_station_insert_id();

	/**
	 * Return the ID of the last inserted context
	 */
	int last_context_insert_id();

	/**
	 * Get the report id from this record.
	 *
	 * If rep_memo is specified instead, the corresponding report id is queried in
	 * the database and set as "rep_cod" in the record.
	 */
	int get_rep_cod(Record& rec);

	/*
	 * Lookup, insert or replace data in station taking the values from
	 * rec.
	 *
	 * If rec did not contain ana_id, it will be set by this function.
	 *
	 * @param rec
	 *   The record with the station information
	 * @param can_add
	 *   If true we can insert new stations in the database, if false we
	 *   only look up existing records and raise an exception if missing
	 * @returns
	 *   The station ID
	 */
	int obtain_station(Record& rec, bool can_add=true);

	/*
	 * Lookup, insert or replace data in station taking the values from
	 * rec.
	 *
	 * If rec did not contain context_id, it will be set by this function.
	 *
	 * @param rec
	 *   The record with the context information
	 * @returns
	 *   The context ID
	 */
	int obtain_context(Record& rec);

	/**
	 * Insert a record into the database
	 *
	 * In a record with the same phisical situation already exists, the function
	 * fails.
	 *
	 * ana_id and context_id will be set in the record at the end of this function.
	 *
	 * @param rec
	 *   The record to insert.
	 * @param can_replace
	 *   If true, then existing data can be rewritten, else data can only be added.
	 * @param station_can_add
	 *   If true, then it is allowed to add new station records to the database.
	 *   Otherwise, data can be added only by reusing existing ones.
	 */
	void insert(Record& rec, bool can_replace, bool station_can_add);

	/**
	 * Remove data from the database
	 *
	 * @param rec
	 *   The record with the query data (see technical specifications, par. 1.6.4
	 *   "parameter output/input") to select the items to be deleted
	 */
	void remove(const Record& rec);
};

#if 0

/**
 * Remove orphan values from the database.
 *
 * Orphan values are currently:
 * \li context values for which no data exists
 * \li station values for which no context exists
 *
 * Depending on database size, this routine can take a few minutes to execute.
 *
 * @param db
 *   Database to operate on
 * @return
 *   The error indicator for the function (See @ref error.h)
 */
dba_err dba_db_remove_orphans(dba_db db);

/**
 * Query QC data
 *
 * @param db
 *   The dballe session id
 * @param id_context
 *   The database id of the context related to the attributes to retrieve
 * @param id_var
 *   The varcode of the variable related to the attributes to retrieve.  See @ref vartable.h
 * @param qcs
 *   The WMO codes of the QC values requested.  If it is NULL, then all values
 *   are returned.
 * @param qcs_size
 *   Number of elements in qcs
 * @param attrs
 *   The dba_record that will hold the resulting attributes
 * @retval count
 *   Number of QC items returned in qc
 * @return
 *   The error indicator for the function (See @ref error.h)
 */
dba_err dba_db_qc_query(dba_db db, int id_context, dba_varcode id_var, const dba_varcode* qcs, size_t qcs_size, dba_record attrs, int* count);

/**
 * Insert a new QC value into the database.
 *
 * @param db
 *   The dballe session id
 * @param id_context
 *   The database id of the context related to the attributes to insert
 * @param id_var
 *   The varcode of the variable related to the attributes to add.  See @ref vartable.h
 * @param attrs
 *   The record with the attributes to be added
 * @param can_replace
 *   If true, then existing data can be rewritten, else data can only be added.
 * @return
 *   The error indicator for the function (See @ref error.h)
 */
dba_err dba_db_qc_insert_or_replace(dba_db db, int id_context, dba_varcode id_var, dba_record attrs, int can_replace);

/**
 * Insert a new QC value into the database.
 *
 * If the same QC value exists for the same data, it is
 * overwritten
 *
 * @param db
 *   The dballe session id
 * @param id_context
 *   The database id of the context related to the attributes to insert
 * @param id_var
 *   The varcode of the variable related to the attributes to add.  See @ref vartable.h
 * @param attrs
 *   The record with the attributes to be added
 * @return
 *   The error indicator for the function (See @ref error.h)
 */
dba_err dba_db_qc_insert(dba_db db, int id_context, dba_varcode id_var, dba_record attrs);

/**
 * Insert a new QC value into the database.
 *
 * If the same QC value exists for the same data, the function fails.
 *
 * @param db
 *   The dballe session id
 * @param id_context
 *   The database id of the context related to the attributes to insert
 * @param id_var
 *   The varcode of the variable related to the attributes to add.  See @ref vartable.h
 * @param attrs
 *   The record with the attributes to be added
 * @return
 *   The error indicator for the function (See @ref error.h)
 */
dba_err dba_db_qc_insert_new(dba_db db, int id_context, dba_varcode id_var, dba_record attrs);

/**
 * Delete QC data for the variable `var' in record `rec' (coming from a previous
 * dba_query)
 *
 * @param db
 *   The dballe session id
 * @param id_context
 *   The database id of the context related to the attributes to remove
 * @param id_var
 *   The varcode of the variable related to the attributes to remove.  See @ref vartable.h
 * @param qcs
 *   Array of WMO codes of the QC data to delete.  If NULL, all QC data
 *   associated to id_data will be deleted.
 * @param qcs_size
 *   Number of items in the qcs array.
 * @return
 *   The error indicator for the function (See @ref error.h)
 */
dba_err dba_db_qc_remove(dba_db db, int id_context, dba_varcode id_var, dba_varcode* qcs, int qcs_size);

#endif

} // namespace dballe

/* vim:set ts=4 sw=4: */
#endif
