#define _GNU_SOURCE
#include <dballe/db/dballe.h>
#include <dballe/core/dba_record.h>
#include <dballe/core/dba_var.h>
#include <dballe/core/dba_csv.h>

#include <config.h>

#include <sql.h>
#include <sqlext.h>
#include <sqltypes.h>

#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>

#include <assert.h>

/*
 * Define to true to enable the use of transactions during writes
 */
#define DBA_USE_DELETE_USING
#define DBA_USE_TRANSACTIONS

//#define TRACE_DB 

#ifdef TRACE_DB
#define TRACE(...) fprintf(stderr, __VA_ARGS__)
#define IFTRACE if (1)
#else
#define TRACE(...) do { } while (0)
#define IFTRACE if (0)
#endif


struct _dba
{
	SQLHDBC	od_conn;
	/*
	 * This is very conservative:
	 * The query size plus 30 possible select values, maximum of 30 characters each
	 * plus 400 characters for the various combinations of the two min and max datetimes,
	 * plus 255 for the blist
	 */
	char querybuf[170 + 30*30 + 400 + 255];
 	char sel_dtmin[25];
 	char sel_dtmax[25];
 	char sel_dtlike[25];
	int sel_latmin;
	int sel_lonmin;
	int sel_latmax;
	int sel_lonmax;
	int sel_mobile;
	const char* sel_ident;
	int sel_pindicator;
	int sel_p1;
	int sel_p2;
	int sel_leveltype;
	int sel_l1;
	int sel_l2;
	int sel_b;
	int sel_rep_cod;
	const char* sel_rep_memo;
	int sel_priority;
	int sel_priomin;
	int sel_priomax;
	int sel_ana_id;
	int sel_data_id;
	int sel_block;
	int sel_station;
};

struct _dba_cursor {
	dba db;
	enum { ANA, DATA, QC } type;
	SQLHSTMT stm;

	int count;

	/* Bound variables */
#define DB_CUR_VAR(type, name) type out_##name; SQLINTEGER out_##name##_ind
#define DB_CUR_CHARVAR(name, len) char out_##name[len]; SQLINTEGER out_##name##_ind
	DB_CUR_VAR(int, lat);
	DB_CUR_VAR(int, lon);
	DB_CUR_VAR(int, mobile);
	DB_CUR_CHARVAR(ident, 64);
	DB_CUR_CHARVAR(identdt, 25);
	DB_CUR_VAR(int, height);
	DB_CUR_VAR(int, heightbaro);
	DB_CUR_VAR(int, block);
	DB_CUR_VAR(int, station);
	DB_CUR_CHARVAR(name, 255);
	DB_CUR_VAR(int, leveltype);
	DB_CUR_VAR(int, l1);
	DB_CUR_VAR(int, l2);
	DB_CUR_VAR(int, pindicator);
	DB_CUR_VAR(int, p1);
	DB_CUR_VAR(int, p2);
	DB_CUR_VAR(int, idvar);
	DB_CUR_CHARVAR(datetime, 25);
	DB_CUR_CHARVAR(value, 255);
	/* DB_CUR_VAR(int, rep_id); */
	DB_CUR_VAR(int, rep_cod);
	DB_CUR_CHARVAR(rep_memo, 20);
	DB_CUR_VAR(int, priority);
	DB_CUR_VAR(int, ana_id);
	DB_CUR_VAR(int, data_id);
#undef DB_CUR_VAR
#undef DB_CUR_CHARVAR
};

static SQLHENV dba_od_env;

static const char* init_tables[] = {
	"repinfo", "pseudoana", "data", "datetime", "levellayer", "timerange", "qc"
};

#ifdef DBA_USE_TRANSACTIONS
#define TABLETYPE "TYPE=InnoDB;"
#else
#define TABLETYPE ";"
#endif
static const char* init_queries[] = {
	"CREATE TABLE repinfo ("
	"   id		     INTEGER PRIMARY KEY,"
	"	memo	 	 VARCHAR(30) NOT NULL,"
	"	description	 VARCHAR(255) NOT NULL,"
	"   prio	     INTEGER NOT NULL,"
	"	descriptor	 CHAR(6) NOT NULL,"
	"	tablea		 INTEGER NOT NULL"
	") " TABLETYPE,
	"CREATE TABLE pseudoana ("
	"   id         INTEGER auto_increment PRIMARY KEY,"
	"   lat        INTEGER NOT NULL,"
	"   lon        INTEGER NOT NULL,"
	"   mobile     CHAR NOT NULL,"
	"   ident      CHAR(64) NOT NULL,"
	"   identdt    DATETIME,"
	"   height     INTEGER,"
	"   heightbaro INTEGER,"
	"   block      INTEGER,"
	"   station    INTEGER,"
	"   name       VARCHAR(255),"
	"   UNIQUE INDEX(lat, lon, mobile, ident(8))"
	") " TABLETYPE,
	"CREATE TABLE data ("
	"   id			  INTEGER auto_increment PRIMARY KEY,"
	"	id_var        INTEGER NOT NULL,"
	"	value         VARCHAR(255) NOT NULL,"
	"   id_datetime   INTEGER NOT NULL,"
	"   id_report	  INTEGER NOT NULL,"
	"	id_pseudoana  INTEGER NOT NULL,"
	"	id_levellayer INTEGER NOT NULL,"
	"	id_timerange  INTEGER NOT NULL,"
	"   UNIQUE INDEX(id_var, id_pseudoana, id_levellayer, id_timerange, id_datetime, id_report)"
	") " TABLETYPE,
	"CREATE TABLE datetime ("
	"   id			  INTEGER auto_increment PRIMARY KEY,"
	"   datetime	  DATETIME NOT NULL,"
	"   UNIQUE INDEX (datetime)"
	") " TABLETYPE,
	"CREATE TABLE levellayer ("
	"   id   INTEGER auto_increment PRIMARY KEY,"
	"	type INTEGER NOT NULL,"
	"	l1   INTEGER NOT NULL,"
	"	l2   INTEGER NOT NULL,"
	"   UNIQUE INDEX(type, l1, l2)"
	") " TABLETYPE,
	"CREATE TABLE timerange ("
	"   id   INTEGER auto_increment PRIMARY KEY,"
	"	type INTEGER NOT NULL,"
	"	p1   INTEGER NOT NULL,"
	"	p2   INTEGER NOT NULL,"
	"   UNIQUE INDEX (type, p1, p2)"
	") " TABLETYPE,
	"CREATE TABLE qc ("
	"   id_data INTEGER NOT NULL,"
	"   type    INTEGER NOT NULL,"
	"   value   VARCHAR(255) NOT NULL,"
	"   INDEX (id_data),"
	"   UNIQUE INDEX (id_data, type)"
	") " TABLETYPE,
	/*
	"CREATE TABLE Tipi ("
	"	id INTEGER PRIMARY KEY,"
	"	wmo_code INTEGER,"
	"	unit VARCHAR(10) NOT NULL,"
	"	conv_mul FLOAT,"
	"	conv_add FLOAT"
	")",
	"CREATE TABLE Datetime ("
	"	id INTEGER PRIMARY KEY,"
	"	date DATE NOT NULL,"
	"	time TIME NOT NULL"
	")"
	*/
};


/**
 * Copy informations from the ODBC diagnostic record to the dba error
 * report
 */
static dba_err dba_error_odbc(SQLSMALLINT handleType, SQLHANDLE handle, const char* fmt, ...)
{
	va_list ap;
	static const int strsize = 200;
	char stat[10], msg[strsize];
	char* context;
	SQLINTEGER err;
	SQLSMALLINT mlen;

	SQLGetDiagRec(handleType, handle, 1, stat, &err, msg, strsize, &mlen);

	va_start(ap, fmt);
	vasprintf(&context, fmt, ap);
	va_end(ap);

	return dba_error_generic0(DBA_ERR_ODBC, context, strndup(msg, mlen));
}

dba_err dba_init()
{
	// Allocate ODBC environment handle and register version 
	int res = SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &dba_od_env);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
		return dba_error_odbc(SQL_HANDLE_ENV, dba_od_env, "Allocating main environment handle");

	res = SQLSetEnvAttr(dba_od_env, SQL_ATTR_ODBC_VERSION, (void*)SQL_OV_ODBC3, 0); 
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
	{
		dba_err res = dba_error_odbc(SQL_HANDLE_ENV, dba_od_env, "Asking for ODBC version 3");
		SQLFreeHandle(SQL_HANDLE_ENV, dba_od_env);
		return res;
	}

	return dba_error_ok();
}

dba_err dba_shutdown()
{
	SQLFreeHandle(SQL_HANDLE_ENV, dba_od_env);
	/* TODO: warn about all allocated resources and free them */

	return dba_error_ok();
}

dba_err dba_open(const char* dsn, const char* user, const char* password, dba* db)
{
	int sqlres;

	/* Allocate a new handle */
	*db = (dba)calloc(1, sizeof(struct _dba));
	if (!*db)
		return dba_error_alloc("trying to allocate a new dba object");

	/* Allocate the ODBC connection handle */
	sqlres = SQLAllocHandle(SQL_HANDLE_DBC, dba_od_env, &((*db)->od_conn));
	if ((sqlres != SQL_SUCCESS) && (sqlres != SQL_SUCCESS_WITH_INFO))
	{
		dba_err err = dba_error_odbc(SQL_HANDLE_DBC, (*db)->od_conn,
				"Allocating new connection handle");
		free(*db);
		*db = 0;
		return err;
	}

	/* Set the connection timeout */
	/* SQLSetConnectAttr(pc.od_conn, SQL_LOGIN_TIMEOUT, (SQLPOINTER *)5, 0); */

	/* Connect to the DSN */
	sqlres = SQLConnect((*db)->od_conn,
						(SQLCHAR*)dsn, SQL_NTS,
						(SQLCHAR*)user, SQL_NTS,
						(SQLCHAR*)(password == NULL ? "" : password), SQL_NTS);
	if ((sqlres != SQL_SUCCESS) && (sqlres != SQL_SUCCESS_WITH_INFO))
	{
		dba_err err = dba_error_odbc(SQL_HANDLE_DBC, (*db)->od_conn,
				"Connecting to DSN %s as user %s", dsn, user);
		SQLFreeHandle(SQL_HANDLE_DBC, (*db)->od_conn);
		free(*db);
		*db = 0;
		return err;
	}
	
	return dba_error_ok();
}

dba_err dba_reset(dba db, const char* deffile)
{
	int res;
	int i;
	SQLHSTMT stm;
	dba_err err;

	assert(db);

	if (deffile == 0)
	{
		deffile = getenv("DBA_REPINFO");
		if (deffile == 0 || deffile[0] == 0)
			deffile = CONF_DIR "/repinfo.csv";
	}

	/* Open the input CSV file */
	FILE* in = fopen(deffile, "r");
	if (in == NULL)
		return dba_error_system("opening file %s", deffile);

	/* Allocate statement handle */
	res = SQLAllocHandle(SQL_HANDLE_STMT, db->od_conn, &stm);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
	{
		err = dba_error_odbc(SQL_HANDLE_STMT, stm, "Allocating new statement handle");
		goto fail0;
	}

	/* Drop existing tables */
	for (i = 0; i < sizeof(init_tables) / sizeof(init_tables[0]); i++)
	{
		char buf[100];
		int len = snprintf(buf, 100, "DROP TABLE IF EXISTS %s", init_tables[i]);
		res = SQLExecDirect(stm, buf, len);
		if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
		{
			err = dba_error_odbc(SQL_HANDLE_STMT, stm,
					"Removing old table %s", init_tables[i]);
			goto fail1;
		}
	}

	/* Create tables */
	for (i = 0; i < sizeof(init_queries) / sizeof(init_queries[0]); i++)
	{
		/* Casting out 'const' because ODBC API is not const-conscious */
		res = SQLExecDirect(stm, (char*)init_queries[i], SQL_NTS);
		if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
		{
			err = dba_error_odbc(SQL_HANDLE_STMT, stm,
					"Executing database-initialization query %s", init_queries[i]);
			goto fail1;
		}
	}

	/* Populate the tables with values */
	{
		int id;
		char memo[30];
		char description[255];
		int prio;
		char descriptor[6];
		int tablea;
		int i;
		char* columns[7];
		int line;

		res = SQLPrepare(stm,
				"INSERT INTO repinfo (id, memo, description, prio, descriptor, tablea)"
				"     VALUES (?, ?, ?, ?, ?, ?)", SQL_NTS);
		if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
		{
			err = dba_error_odbc(SQL_HANDLE_STMT, stm, "compiling query to insert into 'repinfo'");
			goto fail1;
		}

		SQLBindParameter(stm, 1, SQL_PARAM_INPUT, SQL_C_ULONG, SQL_INTEGER, 0, 0, &id, 0, 0);
		SQLBindParameter(stm, 2, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, 0, 0, memo, 0, 0);
		SQLBindParameter(stm, 3, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, 0, 0, description, 0, 0);
		SQLBindParameter(stm, 4, SQL_PARAM_INPUT, SQL_C_LONG, SQL_INTEGER, 0, 0, &prio, 0, 0);
		SQLBindParameter(stm, 5, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, 0, 0, descriptor, 0, 0);
		SQLBindParameter(stm, 6, SQL_PARAM_INPUT, SQL_C_ULONG, SQL_INTEGER, 0, 0, &tablea, 0, 0);

		for (line = 0; (i = dba_csv_read_next(in, columns, 7)) != 0; line++)
		{
			if (i != 6)
			{
				err = dba_error_parse(deffile, line, "Expected 6 columns, got %d", i);
				goto fail1;
			}
				
			id = strtol(columns[0], 0, 10);
			strncpy(memo, columns[1], 30); memo[29] = 0;
			strncpy(description, columns[2], 255); description[254] = 0;
			prio = strtol(columns[3], 0, 10);
			strncpy(descriptor, columns[4], 6); descriptor[5] = 0;
			tablea = strtol(columns[5], 0, 10);

			res = SQLExecute(stm);
			if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
			{
				err = dba_error_odbc(SQL_HANDLE_STMT, stm, "inserting new data into 'data'");
				goto fail1;
			}

			for (i = 0; i < 6; i++)
				free(columns[i]);
		}
	}

	SQLFreeHandle(SQL_HANDLE_STMT, stm);

	return dba_error_ok();

fail1:
	SQLFreeHandle(SQL_HANDLE_STMT, stm);
fail0:
	fclose(in);
	return err;
}

dba_err dba_close(dba db)
{
	assert(db);

	SQLDisconnect(db->od_conn);
	SQLFreeHandle(SQL_HANDLE_DBC, db->od_conn);
	free(db);

	return dba_error_ok();
}

static dba_err dba_last_insert_id(SQLHDBC od_conn, int* id)
{
	SQLHSTMT stm;
	int res;
	SQLINTEGER id_ind;
	dba_err err;

	/* Allocate statement handle for select */
	res = SQLAllocHandle(SQL_HANDLE_STMT, od_conn, &stm);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
		return dba_error_odbc(SQL_HANDLE_STMT, stm, "Allocating new statement");

	/* Bind variable and indicator */
	SQLBindCol(stm, 1, SQL_C_SLONG, id, sizeof(*id), &id_ind);
	
	res = SQLExecDirect(stm, "SELECT LAST_INSERT_ID()", SQL_NTS);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
	{
		err = dba_error_odbc(SQL_HANDLE_STMT, stm, "querying last inserted ID");
		goto dba_last_insert_id_failed;
	}

	if (SQLFetch(stm) == SQL_NO_DATA)
	{
		err = dba_error_odbc(SQL_HANDLE_STMT, stm, "retrieving results of query for last inserted ID");
		goto dba_last_insert_id_failed;
	}

	if (id_ind != sizeof(*id))
	{
		err = dba_error_consistency("checking that the size of the last insert ID coming from the database is correct");
		goto dba_last_insert_id_failed;
	}

	SQLFreeHandle(SQL_HANDLE_STMT, stm);
	return dba_error_ok();

dba_last_insert_id_failed:
	SQLFreeHandle(SQL_HANDLE_STMT, stm);
	return err;
}

dba_err dba_rep_cod_from_memo(dba db, const char* memo, int* rep_cod)
{
	const char* query = "SELECT id FROM repinfo WHERE memo = ?";
	dba_err err = DBA_OK;
	SQLHSTMT stm;
	SQLINTEGER rep_cod_ind;
	int res;

	/* Allocate statement handle */
	res = SQLAllocHandle(SQL_HANDLE_STMT, db->od_conn, &stm);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
		return dba_error_odbc(SQL_HANDLE_STMT, stm, "Allocating new statement handle");

	/* Bind input parameters */
	SQLBindParameter(stm, 1, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, 0, 0, (char*)memo, 0, 0);

	/* Bind variable and indicator for SELECT results */
	SQLBindCol(stm, 1, SQL_C_SLONG, rep_cod, sizeof(int), &rep_cod_ind);

	/* Casting to char* because ODBC is unaware of const */
	res = SQLExecDirect(stm, (char*)query, SQL_NTS);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
	{
		err = dba_error_odbc(SQL_HANDLE_STMT, stm, "looking for existing pseudoana");
		goto cleanup;
	}

	/* Get one result */
	if (SQLFetch(stm) == SQL_NO_DATA)
	{
		err = dba_error_notfound("looking for report informations for '%s'", memo);
		goto cleanup;
	}

cleanup:
	SQLFreeHandle(SQL_HANDLE_STMT, stm);
	return err;
}


static dba_err dba_insert_pseudoana(dba db, dba_record rec, int* id, int rewrite)
{
	dba_err err = DBA_OK;
	const char* query_sel =
		"SELECT id FROM pseudoana WHERE lat=? AND lon=? AND mobile=? AND ident=?";
	const char* query_repl =
		"UPDATE pseudoana SET lat=?, lon=?, mobile=?, ident=?, identdt=?, height=?, heightbaro=?,"
		"                     block=?, station=?, name=? WHERE id=?";
	const char* query =
		"INSERT INTO pseudoana (lat, lon, mobile, ident, identdt, height, heightbaro, block, station, name)"
		" VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
	int lat;
	int lon;
	int mobile;
	const char* ident;
	const char *year, *month, *day, *hour, *min, *val;
	char datebuf[30];
	SQLINTEGER datebuf_ind;
	int height;
	SQLINTEGER height_ind;
	int heightbaro;
	SQLINTEGER heightbaro_ind;
	int block;
	SQLINTEGER block_ind;
	int station;
	SQLINTEGER station_ind;
	const char* name;
	SQLINTEGER name_ind;
	SQLHSTMT stm;
	int res;
	int old_id;
	SQLINTEGER old_id_ind;
	int has_data = 0;

	assert(db);

	/* Look for an existing ID if provided */
	{
		const char* val;
		if ((val = dba_record_enqk(rec, "ana_id")) != NULL)
			*id = strtol(val, 0, 10);
		else
			*id = -1;
	}

	/* If we don't need to rewrite, we are done */
	if (*id != -1 && !rewrite)
		return dba_error_ok();

	/* Allocate statement handle */
	res = SQLAllocHandle(SQL_HANDLE_STMT, db->od_conn, &stm);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
		return dba_error_odbc(SQL_HANDLE_STMT, stm, "Allocating new statement handle");

	/* Look for the key data in the record */
	DBA_RUN_OR_GOTO(cleanup, dba_enqi(rec, "lat", &lat));
	DBA_RUN_OR_GOTO(cleanup, dba_enqi(rec, "lon", &lon));
	DBA_RUN_OR_GOTO(cleanup, dba_enqi(rec, "mobile", &mobile));
	if (mobile)
	{
		DBA_RUN_OR_GOTO(cleanup, dba_enqc(rec, "ident", &ident));
	} else {
		ident = "";
	}

	/* Bind key parameters */
	SQLBindParameter(stm, 1, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0, &lat, 0, 0);
	SQLBindParameter(stm, 2, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0, &lon, 0, 0);
	SQLBindParameter(stm, 3, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_SMALLINT, 0, 0, &mobile, 0, 0);
	/* Casting to char* because ODBC is unaware of const */
	SQLBindParameter(stm, 4, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, 0, 0, (char*)ident, 0, 0);

	/* Check for an existing pseudoana with these data */
	if (*id == -1)
	{
		/* Bind variable and indicator for SELECT results */
		SQLBindCol(stm, 1, SQL_C_SLONG, &old_id, sizeof(old_id), &old_id_ind);
		
		/* Casting to char* because ODBC is unaware of const */
		res = SQLExecDirect(stm, (char*)query_sel, SQL_NTS);
		if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
		{
			err = dba_error_odbc(SQL_HANDLE_STMT, stm, "looking for existing pseudoana");
			goto cleanup;
		}

		/* Get the result */
		if (SQLFetch(stm) != SQL_NO_DATA)
		{
			if (old_id_ind != sizeof(old_id))
			{
				err = dba_error_consistency("checking that the size of the ID coming from the database is correct");
				goto cleanup;
			}

			*id = old_id;
			has_data = 1;

			/* If we don't have to update the data, we're finished */
			if (! rewrite)
			{
				SQLFreeHandle(SQL_HANDLE_STMT, stm);
				return dba_error_ok();
			}
		}

		res = SQLCloseCursor(stm);
		if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
		{
			if (has_data)
				err = dba_error_odbc(SQL_HANDLE_STMT, stm, "preparing for replacing into pseudoana");
			else
				err = dba_error_odbc(SQL_HANDLE_STMT, stm, "preparing for inserting into pseudoana");
			goto cleanup;
		}
	}

	/* Insert or update the values in the database */

	/* Identdt needs to be computed */
	if ((year  = dba_record_enqk(rec, "year_ident"))  != NULL &&
	    (month = dba_record_enqk(rec, "month_ident")) != NULL &&
		(day   = dba_record_enqk(rec, "day_ident"))   != NULL &&
		(hour  = dba_record_enqk(rec, "hour_ident"))  != NULL &&
		(min   = dba_record_enqk(rec, "min_ident"))   != NULL)
	{
		snprintf(datebuf, 30, "%04ld-%02ld-%02ld %02ld:%02ld:00", 
				strtol(year, 0, 10),
				strtol(month, 0, 10),
				strtol(day, 0, 10),
				strtol(hour, 0, 10),
				strtol(min, 0, 10));
		datebuf_ind = SQL_NTS;
	} else {
		datebuf[0] = 0;
		datebuf_ind = SQL_NULL_DATA;
	}
	SQLBindParameter(stm, 5, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, 0, 0, datebuf, 0, &datebuf_ind);

	if ((val = dba_record_enqk(rec, "height")) != NULL)
	{
		height_ind = 0;
		height = strtol(val, 0, 10);
	} else
		height_ind = SQL_NULL_DATA;
	SQLBindParameter(stm, 6, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0, &height, 0, &height_ind);
	
	if ((val = dba_record_enqk(rec, "heightbaro")) != NULL)
	{
		heightbaro_ind = 0;
		heightbaro = strtol(val, 0, 10);
	} else
		heightbaro_ind = SQL_NULL_DATA;
	SQLBindParameter(stm, 7, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0, &heightbaro, 0, &heightbaro_ind);
	
	if ((val = dba_record_enqk(rec, "block")) != NULL)
	{
		block_ind = 0;
		block = strtol(val, 0, 10);
	} else
		block_ind = SQL_NULL_DATA;
	SQLBindParameter(stm, 8, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0, &block, 0, &block_ind);
	
	if ((val = dba_record_enqk(rec, "station")) != NULL)
	{
		station_ind = 0;
		station = strtol(val, 0, 10);
	} else
		station_ind = SQL_NULL_DATA;
	SQLBindParameter(stm, 9, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0, &station, 0, &station_ind);
	
	if ((name = dba_record_enqk(rec, "name")) != NULL)
		name_ind = SQL_NTS;
	else
	{
		name = "";
		name_ind = SQL_NULL_DATA;
	}
	/* Casting to char* because ODBC is unaware of const */
	SQLBindParameter(stm, 10, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, 0, 0, (char*)name, 0, &name_ind);

	if (*id != -1)
	{
		SQLBindParameter(stm, 11, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0, id, 0, 0);
		/* Casting to char* because ODBC is unaware of const */
		res = SQLExecDirect(stm, (char*)query_repl, SQL_NTS);

		if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
		{
			err = dba_error_odbc(SQL_HANDLE_STMT, stm, "replacing old data in pseudoana");
			goto cleanup;
		}

	} else {
		/* Casting to char* because ODBC is unaware of const */
		res = SQLExecDirect(stm, (char*)query, SQL_NTS);

		if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
		{
			err = dba_error_odbc(SQL_HANDLE_STMT, stm, "inserting new data into pseudoana");
			goto cleanup;
		}

		/* Get the ID of the last inserted pseudoana */
		DBA_RUN_OR_GOTO(cleanup, dba_last_insert_id(db->od_conn, id));
	}
	
	SQLFreeHandle(SQL_HANDLE_STMT, stm);

cleanup:
	return err == DBA_OK ? dba_error_ok() : err;
}

static dba_err dba_remove_pseudoana(dba db, int id)
{
	const char* query = "DELETE FROM pseudoana WHERE id = ?";
	SQLHSTMT stm;
	int res;

	assert(db);

	/* Allocate statement handle */
	res = SQLAllocHandle(SQL_HANDLE_STMT, db->od_conn, &stm);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
		return dba_error_odbc(SQL_HANDLE_STMT, stm, "Allocating new statement handle");

	/* Bind parameter */
	SQLBindParameter(stm, 1, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0, &id, 0, 0);

	/* Casting to char* because ODBC is unaware of const */
	res = SQLExecDirect(stm, (char*)query, SQL_NTS);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
	{
		dba_err err = dba_error_odbc(SQL_HANDLE_STMT, stm, "inserting new data into pseudoana");
		SQLFreeHandle(SQL_HANDLE_STMT, stm);
		return err;
	}

	SQLFreeHandle(SQL_HANDLE_STMT, stm);
	return dba_error_ok();
}

#if 0
static dba_err dba_insert_report(dba db, dba_record rec, int* id)
{
	const char* query = "INSERT INTO report (id, type) VALUES (NULL, ?)";
	SQLHSTMT stm;
	int res;
	int rep_cod;
	dba_err err = DBA_OK;

	assert(db);

	/* Allocate statement handle */
	res = SQLAllocHandle(SQL_HANDLE_STMT, db->od_conn, &stm);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
		return dba_error_odbc(SQL_HANDLE_STMT, stm, "Allocating new statement handle");

	DBA_RUN_OR_GOTO(dba_insert_report_failed, dba_enqi(rec, "rep_cod", &rep_cod));
	SQLBindParameter(stm, 1, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_SMALLINT, 0, 0, &rep_cod, 0, 0);
	
	/* Casting to char* because ODBC is unaware of const */
	res = SQLExecDirect(stm, (char*)query, SQL_NTS);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
	{
		err = dba_error_odbc(SQL_HANDLE_STMT, stm, "inserting new data into report");
		goto dba_insert_report_failed;
	}

	SQLFreeHandle(SQL_HANDLE_STMT, stm);

	/* Get the ID of the last inserted report */
	return dba_last_insert_id(db->od_conn, id);

dba_insert_report_failed:
	SQLFreeHandle(SQL_HANDLE_STMT, stm);
	return err;
}
#endif

static dba_err dba_insert_levellayer(dba db, dba_record rec, int* id)
{
	const char* query_sel =
		"SELECT id FROM levellayer WHERE type=? AND l1=? AND l2=?";
	const char* query =
		"INSERT INTO levellayer (type, l1, l2)"
		" VALUES (?, ?, ?);";
	int type;
	int l1;
	int l2;
	int old_id;
	SQLINTEGER old_id_ind;
	SQLHSTMT stm;
	int res;
	dba_err err;

	assert(db);

	/* Allocate statement handle */
	res = SQLAllocHandle(SQL_HANDLE_STMT, db->od_conn, &stm);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
		return dba_error_odbc(SQL_HANDLE_STMT, stm, "Allocating new statement handle");

	/* Retrieve data */
	if ((err = dba_enqi(rec, "leveltype", &type)))
		goto dba_insert_levellayer_failed;
	if ((err = dba_enqi(rec, "l1", &l1)))
		goto dba_insert_levellayer_failed;
	if ((err = dba_enqi(rec, "l2", &l2)))
		goto dba_insert_levellayer_failed;

	/* Bind parameters */
	SQLBindParameter(stm, 1, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0, &type, 0, 0);
	SQLBindParameter(stm, 2, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0, &l1, 0, 0);
	SQLBindParameter(stm, 3, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0, &l2, 0, 0);


	/* Check for an existing levellayer with these data */

	/* Bind variable and indicator for SELECT results */
	SQLBindCol(stm, 1, SQL_C_SLONG, &old_id, sizeof(old_id), &old_id_ind);
	
	/* Casting to char* because ODBC is unaware of const */
	res = SQLExecDirect(stm, (char*)query_sel, SQL_NTS);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
	{
		err = dba_error_odbc(SQL_HANDLE_STMT, stm, "looking for existing levellayer");
		goto dba_insert_levellayer_failed;
	}

	/* If there is an existing record, use its ID and don't do an INSERT */
	if (SQLFetch(stm) != SQL_NO_DATA)
	{
		if (old_id_ind != sizeof(old_id))
		{
			err = dba_error_consistency("checking that the size of the ID coming from the database is correct");
			goto dba_insert_levellayer_failed;
		}

		*id = old_id;

		SQLFreeHandle(SQL_HANDLE_STMT, stm);
		return dba_error_ok();
	}

	res = SQLCloseCursor(stm);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
	{
		err = dba_error_odbc(SQL_HANDLE_STMT, stm, "preparing for inserting into levellayer");
		goto dba_insert_levellayer_failed;
	}

	/* Casting to char* because ODBC is unaware of const */
	res = SQLExecDirect(stm, (char*)query, SQL_NTS);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
	{
		err = dba_error_odbc(SQL_HANDLE_STMT, stm, "inserting new data into levellayer");
		goto dba_insert_levellayer_failed;
	}

	SQLFreeHandle(SQL_HANDLE_STMT, stm);


	/* Get the ID of the last inserted levellayer */
	return dba_last_insert_id(db->od_conn, id);

dba_insert_levellayer_failed:
	SQLFreeHandle(SQL_HANDLE_STMT, stm);
	return err;
}

static dba_err dba_insert_timerange(dba db, dba_record rec, int* id)
{
	const char* query_sel =
		"SELECT id FROM timerange WHERE type=? AND p1=? AND p2=?";
	const char* query =
		"INSERT INTO timerange (type, p1, p2)"
		" VALUES (?, ?, ?);";
	int type;
	int p1;
	int p2;
	SQLHSTMT stm;
	int res;
	dba_err err;
	int old_id;
	SQLINTEGER old_id_ind;

	assert(db);

	/* Allocate statement handle */
	res = SQLAllocHandle(SQL_HANDLE_STMT, db->od_conn, &stm);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
		return dba_error_odbc(SQL_HANDLE_STMT, stm, "Allocating new statement handle");

	/* Retrieve data */
	if ((err = dba_enqi(rec, "pindicator", &type)))
		goto dba_insert_timerange_failed;
	if ((err = dba_enqi(rec, "p1", &p1)))
		goto dba_insert_timerange_failed;
	if ((err = dba_enqi(rec, "p2", &p2)))
		goto dba_insert_timerange_failed;

	/* Bind parameters */
	SQLBindParameter(stm, 1, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0, &type, 0, 0);
	SQLBindParameter(stm, 2, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0, &p1, 0, 0);
	SQLBindParameter(stm, 3, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0, &p2, 0, 0);
	
	/* Check for an existing levellayer with these data */

	/* Bind variable and indicator for SELECT results */
	SQLBindCol(stm, 1, SQL_C_SLONG, &old_id, sizeof(old_id), &old_id_ind);
	
	/* Casting to char* because ODBC is unaware of const */
	res = SQLExecDirect(stm, (char*)query_sel, SQL_NTS);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
	{
		err = dba_error_odbc(SQL_HANDLE_STMT, stm, "looking for existing timerange");
		goto dba_insert_timerange_failed;
	}

	/* If there is an existing record, use its ID and don't do an INSERT */
	if (SQLFetch(stm) != SQL_NO_DATA)
	{
		if (old_id_ind != sizeof(old_id))
		{
			err = dba_error_consistency("checking that the size of the ID coming from the database is correct");
			goto dba_insert_timerange_failed;
		}

		*id = old_id;

		SQLFreeHandle(SQL_HANDLE_STMT, stm);
		return dba_error_ok();
	}

	res = SQLCloseCursor(stm);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
	{
		err = dba_error_odbc(SQL_HANDLE_STMT, stm, "preparing for inserting into timerange");
		goto dba_insert_timerange_failed;
	}

	/* Casting to char* because ODBC is unaware of const */
	res = SQLExecDirect(stm, (char*)query, SQL_NTS);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
	{
		err = dba_error_odbc(SQL_HANDLE_STMT, stm, "inserting new data into timerange");
		goto dba_insert_timerange_failed;
	}

	SQLFreeHandle(SQL_HANDLE_STMT, stm);


	/* Get the ID of the last inserted timerange */
	return dba_last_insert_id(db->od_conn, id);

dba_insert_timerange_failed:
	SQLFreeHandle(SQL_HANDLE_STMT, stm);
	return err;
}

static dba_err dba_insert_datetime(dba db, dba_record rec, int* id)
{
	const char* query_sel =
		"SELECT id FROM datetime WHERE datetime=?";
	const char* query =
		"INSERT INTO datetime (datetime)"
		" VALUES (?);";
	const char *year, *month, *day, *hour, *min, *sec;
	char datebuf[30];
	SQLINTEGER datebuf_ind;
	SQLHSTMT stm;
	int res;
	dba_err err;
	int old_id;
	SQLINTEGER old_id_ind;

	assert(db);

	/* Allocate statement handle */
	res = SQLAllocHandle(SQL_HANDLE_STMT, db->od_conn, &stm);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
		return dba_error_odbc(SQL_HANDLE_STMT, stm, "Allocating new statement handle");

	/* Retrieve data */
	/* Also input the seconds, defaulting to 0 if not found */
	sec = dba_record_enqk(rec, "sec");
	/* Datetime needs to be computed */
	if ((year  = dba_record_enqk(rec, "year")) != NULL &&
		(month = dba_record_enqk(rec, "month")) != NULL &&
		(day   = dba_record_enqk(rec, "day")) != NULL &&
		(hour  = dba_record_enqk(rec, "hour")) != NULL &&
		(min   = dba_record_enqk(rec, "min")) != NULL)
		datebuf_ind = snprintf(datebuf, 30,
				"%04ld-%02ld-%02ld %02ld:%02ld:%02ld",
					strtol(year, 0, 10),
					strtol(month, 0, 10),
					strtol(day, 0, 10),
					strtol(hour, 0, 10),
					strtol(min, 0, 10),
					sec != NULL ? strtol(sec, 0, 10) : 0);
	else
	{
		err = dba_error_notfound("looking for datetime informations");
		goto fail;
	}

	/* Bind parameters */
	SQLBindParameter(stm, 1, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, 0, 0, &datebuf, 0, &datebuf_ind);
	
	/* Check for an existing datetime with these data */

	/* Bind variable and indicator for SELECT results */
	SQLBindCol(stm, 1, SQL_C_SLONG, &old_id, sizeof(old_id), &old_id_ind);
	
	/* Casting to char* because ODBC is unaware of const */
	res = SQLExecDirect(stm, (char*)query_sel, SQL_NTS);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
	{
		err = dba_error_odbc(SQL_HANDLE_STMT, stm, "looking for existing datetime");
		goto fail;
	}

	/* If there is an existing record, use its ID and don't do an INSERT */
	if (SQLFetch(stm) != SQL_NO_DATA)
	{
		if (old_id_ind != sizeof(old_id))
		{
			err = dba_error_consistency("checking that the size of the ID coming from the database is correct");
			goto fail;
		}

		*id = old_id;

		SQLFreeHandle(SQL_HANDLE_STMT, stm);
		return dba_error_ok();
	}

	res = SQLCloseCursor(stm);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
	{
		err = dba_error_odbc(SQL_HANDLE_STMT, stm, "preparing for inserting into datetime");
		goto fail;
	}

	/* Casting to char* because ODBC is unaware of const */
	res = SQLExecDirect(stm, (char*)query, SQL_NTS);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
	{
		err = dba_error_odbc(SQL_HANDLE_STMT, stm, "inserting new data into datetime");
		goto fail;
	}

	SQLFreeHandle(SQL_HANDLE_STMT, stm);


	/* Get the ID of the last inserted timerange */
	return dba_last_insert_id(db->od_conn, id);

fail:
	SQLFreeHandle(SQL_HANDLE_STMT, stm);
	return err;
}

static dba_err dba_run_one_shot_query(SQLHDBC od_conn, const char* query)
{
	SQLHSTMT stm;
	int res;

	/* Allocate statement handle */
	res = SQLAllocHandle(SQL_HANDLE_STMT, od_conn, &stm);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
		return dba_error_odbc(SQL_HANDLE_STMT, stm, "Allocating new statement handle");

	/* Casting to char* because ODBC is unaware of const */
	res = SQLExecDirect(stm, (char*)query, SQL_NTS);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
	{
		dba_err err = dba_error_odbc(SQL_HANDLE_STMT, stm, "Beginning a transaction");
		SQLFreeHandle(SQL_HANDLE_STMT, stm);
		return err;
	}

	SQLFreeHandle(SQL_HANDLE_STMT, stm);
	return dba_error_ok();
}


#ifdef DBA_USE_TRANSACTIONS
static dba_err dba_begin(SQLHDBC od_conn) { return dba_run_one_shot_query(od_conn, "BEGIN"); }
static dba_err dba_commit(SQLHDBC od_conn) { return dba_run_one_shot_query(od_conn, "COMMIT"); }
/* Run unchecked to avoid altering the error status */
static void dba_rollback(SQLHDBC od_conn)
{
	SQLHSTMT stm;
	int res;

	/* Allocate statement handle */
	res = SQLAllocHandle(SQL_HANDLE_STMT, od_conn, &stm);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
		return;

	res = SQLExecDirect(stm, "ROLLBACK", 8);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
		return;

	SQLFreeHandle(SQL_HANDLE_STMT, stm);
}
#else
/* TODO: lock and unlock tables instead */
static dba_err dba_begin(SQLHDBC od_conn) { return dba_error_ok(); }
static dba_err dba_commit(SQLHDBC od_conn) { return dba_error_ok(); }
static void dba_rollback(SQLHDBC od_conn) {}
#endif

/*
 * If can_replace, then existing data can be rewritten, else it can only add new data
 *
 * If update_pseudoana, then the pseudoana informations are overwritten using
 * information from `rec'; else data from `rec' is written into pseudoana only
 * if there is no suitable anagraphical data for it.
 */
dba_err dba_insert_or_replace(dba db, dba_record rec, int can_replace, int update_pseudoana)
{
	const char* insert_query =
		"INSERT INTO data (id_var, value, id_datetime, id_report, id_pseudoana, id_levellayer, id_timerange)"
		" VALUES(?, ?, ?, ?, ?, ?, ?)";
	const char* replace_query =
		"REPLACE INTO data (id_var, value, id_datetime, id_report, id_pseudoana, id_levellayer, id_timerange)"
		" VALUES(?, ?, ?, ?, ?, ?, ?)";
	dba_err err;
	dba_record_cursor item;
	int id_pseudoana;
	int id_levellayer;
	int id_timerange;
	int id_datetime;
	/* int id_report; */
	int type_report;
	dba_varcode id_var;
	char datebuf[30];
	SQLINTEGER datebuf_ind;
	char value[255];
	SQLINTEGER value_ind;
	SQLHSTMT stm;
	int res;
	
	assert(db);

	/* Begin the transaction */
	if ((err = dba_begin(db->od_conn)))
		return err;

	/* Insert the pseudoana data, and get the ID */
	if ((err = dba_insert_pseudoana(db, rec, &id_pseudoana, update_pseudoana)))
		goto dba_insert_failed1;

	/* Insert the levellayer data, and get the ID */
	if ((err = dba_insert_levellayer(db, rec, &id_levellayer)))
		goto dba_insert_failed1;

	/* Insert the levellayer data, and get the ID */
	if ((err = dba_insert_timerange(db, rec, &id_timerange)))
		goto dba_insert_failed1;

	/* Insert the datetime data, and get the ID */
	if ((err = dba_insert_datetime(db, rec, &id_datetime)))
		goto dba_insert_failed1;

	/* Insert the report data, and get the ID */
	/*
	if ((err = dba_insert_report(db, rec, &id_report)))
		goto dba_insert_failed1;
	*/


	/* Insert the rest of the fields */

	/* Allocate statement handle */
	res = SQLAllocHandle(SQL_HANDLE_STMT, db->od_conn, &stm);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
	{
		err = dba_error_odbc(SQL_HANDLE_STMT, stm, "Allocating new statement handle");
		goto dba_insert_failed1;
	}

	/* Compile the SQL query */
	/* Casting to char* because ODBC is unaware of const */
	res = SQLPrepare(stm, can_replace ? (char*)replace_query : (char*)insert_query, SQL_NTS);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
	{
		err = dba_error_odbc(SQL_HANDLE_STMT, stm, "compiling query to insert into 'data'");
		goto dba_insert_failed;
	}

	/* Bind parameters */
	SQLBindParameter(stm, 1, SQL_PARAM_INPUT, SQL_C_USHORT, SQL_INTEGER, 0, 0, &id_var, 0, 0);
	SQLBindParameter(stm, 2, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, 0, 0, value, 0, &value_ind);
	SQLBindParameter(stm, 3, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0, &id_datetime, 0, 0);
	/* SQLBindParameter(stm, 4, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0, &id_report, 0, 0); */
	SQLBindParameter(stm, 4, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0, &type_report, 0, 0);
	SQLBindParameter(stm, 5, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0, &id_pseudoana, 0, 0);
	SQLBindParameter(stm, 6, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0, &id_levellayer, 0, 0);
	SQLBindParameter(stm, 7, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0, &id_timerange, 0, 0);

	/* Insert all found variables */
	for (item = dba_record_iterate_first(rec); item != NULL;
			item = dba_record_iterate_next(rec, item))
	{
		/* Datum to be inserted, linked to id_pseudoana and all the other IDs */
		dba_var var = dba_record_cursor_variable(item);
		const char* cur_value;
		const char* rep;

		DBA_RUN_OR_GOTO(dba_insert_failed, dba_var_enqc(var, &cur_value));

		/* Variable ID */
		id_var = dba_var_code(var);

		/* Variable value */
		if ((value_ind = strlen(cur_value)) > 256)
			value_ind = 255;
		strncpy(value, cur_value, value_ind);
		value[value_ind] = 0;

		if ((rep = dba_record_enqk(rec, "rep_cod")) != NULL)
			type_report = strtol(rep, 0, 10);
		else if ((rep = dba_record_enqk(rec, "rep_memo")) != NULL)
			DBA_RUN_OR_GOTO(dba_insert_failed, dba_rep_cod_from_memo(db, rep, &type_report));
		else
		{
			err = dba_error_notfound("looking for report type in rep_cod or rep_memo");
			goto dba_insert_failed;
		}
			
		/* The other IDs are already preset */

		/*
		fprintf(stderr, "Inserting %d %s[%d] %s[%d] %d %d %d %d\n",
				id_var, value, value_ind, datebuf, datebuf_ind, id_report, id_pseudoana, id_levellayer, id_timerange);
		*/

		res = SQLExecute(stm);
		if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
		{
			err = dba_error_odbc(SQL_HANDLE_STMT, stm, "inserting new data into 'data'");
			goto dba_insert_failed;
		}

		{
			int id;
			DBA_RUN_OR_GOTO(dba_insert_failed, dba_last_insert_id(db->od_conn, &id));
			dba_record_cursor_set_id(item, id);
		}
	}
			
	SQLFreeHandle(SQL_HANDLE_STMT, stm);
	if ((err = dba_commit(db->od_conn)))
	{
		dba_rollback(db->od_conn);
		return err;
	}

	/* Insert database ID informations into the record. */
	DBA_RUN_OR_RETURN(dba_seti(rec, "ana_id", id_pseudoana));
	/* DBA_RUN_OR_RETURN(dba_seti(rec, "rep_id", id_report)); */

	return dba_error_ok();

	/* Exits with cleanup after error */
dba_insert_failed:
	SQLFreeHandle(SQL_HANDLE_STMT, stm);
dba_insert_failed1:
	dba_rollback(db->od_conn);
	return err;
}

dba_err dba_insert(dba db, dba_record rec)
{
	return dba_insert_or_replace(db, rec, 1, 1);
}

dba_err dba_insert_new(dba db, dba_record rec)
{
	return dba_insert_or_replace(db, rec, 0, 0);
}

#if 0
dba_err dba_ana_count(dba db, int* count)
{
	SQLHSTMT stm;
	SQLINTEGER id_ind;
	int res;
	dba_err err;

	assert(db);

	/* Allocate statement handle for select */
	res = SQLAllocHandle(SQL_HANDLE_STMT, db->od_conn, &stm);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
		return dba_error_odbc(SQL_HANDLE_STMT, stm, "Allocating new statement");

	/* Bind variable and indicator */
	SQLBindCol(stm, 1, SQL_C_SLONG, count, sizeof(*count), &id_ind);
	
	res = SQLExecDirect(stm, "SELECT COUNT(*) FROM pseudoana", SQL_NTS);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
	{
		err = dba_error_odbc(SQL_HANDLE_STMT, stm, "querying number of entries in table 'pseudoana'");
		goto dba_ana_count_failed;
	}

	if (SQLFetch(stm) == SQL_NO_DATA)
	{
		err = dba_error_odbc(SQL_HANDLE_STMT, stm, "retrieving number of entries in table 'pseudoana'");
		goto dba_ana_count_failed;
	}

	if (id_ind != sizeof(*count))
	{
		err = dba_error_consistency("checking that the size of the count coming from the database is correct");
		goto dba_ana_count_failed;
	}

	SQLFreeHandle(SQL_HANDLE_STMT, stm);
	return dba_error_ok();

dba_ana_count_failed:
	SQLFreeHandle(SQL_HANDLE_STMT, stm);
	return err;
}
#endif

static dba_err dba_cursor_new(dba db, dba_cursor* cur)
{
	assert(db);
	*cur = (dba_cursor)calloc(1, sizeof(struct _dba_cursor));
	if (!*cur)
		return dba_error_alloc("trying to allocate a new dba_cursor object");
	(*cur)->db = db;
	return dba_error_ok();
}

dba_err dba_ana_query(dba db, dba_cursor* cur, int* count)
{
	const char* query =
		"SELECT pa.id, pa.lat, pa.lon, pa.mobile, pa.ident, pa.identdt, pa.height, pa.heightbaro,"
		"       pa.block, pa.station, pa.name"
		"  FROM pseudoana AS pa"
		" ORDER BY pa.id";
	dba_err err;
	SQLHSTMT stm;
	int res;

	assert(db);

	/* Allocate a new cursor */
	DBA_RUN_OR_RETURN(dba_cursor_new(db, cur));

	/* Setup the new cursor */
	(*cur)->type = ANA;

	/* Allocate statement handle */
	res = SQLAllocHandle(SQL_HANDLE_STMT, db->od_conn, &stm);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
	{
		free(*cur);
		return dba_error_odbc(SQL_HANDLE_STMT, stm, "Allocating new statement handle");
	}

	(*cur)->stm = stm;
	/* (*cur)->out_rep_id = -1; */

	/* Bind output fields */
#define DBA_QUERY_BIND(num, type, name) \
	SQLBindCol(stm, num, type, &(*cur)->out_##name, sizeof((*cur)->out_##name), &(*cur)->out_##name##_ind);
	DBA_QUERY_BIND(1, SQL_C_SLONG, ana_id);
	DBA_QUERY_BIND(2, SQL_C_SLONG, lat);
	DBA_QUERY_BIND(3, SQL_C_SLONG, lon);
	DBA_QUERY_BIND(4, SQL_C_SLONG, mobile);
	DBA_QUERY_BIND(5, SQL_C_CHAR, ident);
	DBA_QUERY_BIND(6, SQL_C_CHAR, identdt);
	DBA_QUERY_BIND(7, SQL_C_SLONG, height);
	DBA_QUERY_BIND(8, SQL_C_SLONG, heightbaro);
	DBA_QUERY_BIND(9, SQL_C_SLONG, block);
	DBA_QUERY_BIND(10, SQL_C_SLONG, station);
	DBA_QUERY_BIND(11, SQL_C_CHAR, name);
#undef DBA_QUERY_BIND

	/* Perform the query */
	res = SQLExecDirect(stm, (char*)query, SQL_NTS);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
	{
		err = dba_error_odbc(SQL_HANDLE_STMT, stm, "performing DBALLE ANA query \"%s\"", query);
		goto dba_ana_query_failed;
	}

	/* Get the number of affected rows */
	{
		SQLINTEGER ana_count;
		res = SQLRowCount(stm, &ana_count);
		if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
		{
			err = dba_error_odbc(SQL_HANDLE_STMT, stm, "getting row count");
			goto dba_ana_query_failed;
		}
		(*cur)->count = ana_count;
		*count = ana_count;
		/*fprintf(stderr, "COUNT: %d\n", count);*/
	}

	/* Retrieve results will happen in dba_cursor_next() */

	/* Done.  No need to deallocate the statement, it will be done by
	 * dba_cursor_delete */
	return dba_error_ok();

	/* Exit point with cleanup after error */
dba_ana_query_failed:
	dba_cursor_delete(*cur);
	*cur = 0;
	return err;
}

#define CHECKED_STORE(settype, var) \
	do{ \
		if (cur->out_##var##_ind != SQL_NULL_DATA) {\
			/*fprintf(stderr, "SETTING %s to %d\n", #var, cur->out_##var);*/ \
			dba_err err = dba_##settype(rec, #var, cur->out_##var); \
			if (err) return err; \
		} \
	} while (0)

static dba_err dba_ana_cursor_to_rec(dba_cursor cur, dba_record rec)
{
	assert(cur);
	assert(cur->db);

	/* Copy the resulting data into `rec' */
	CHECKED_STORE(seti, ana_id);
	CHECKED_STORE(seti, lat);
	CHECKED_STORE(seti, lon);
	CHECKED_STORE(seti, mobile);
	if (cur->out_ident_ind != SQL_NULL_DATA && cur->out_ident[0] == 0)
		dba_unset(rec, "ident");
	else
		CHECKED_STORE(setc, ident);
	if (cur->out_identdt_ind != SQL_NULL_DATA)
	{
		/*fprintf(stderr, "SETTING %s to %d\n", #var,  _db_cursor[cur].out_##var); */
		int year, mon, day, hour, min, sec;
		if (sscanf(cur->out_identdt,
					"%04d-%02d-%02d %02d:%02d:%02d", &year, &mon, &day, &hour, &min, &sec) != 6)
			return dba_error_consistency("parsing datetime string \"%s\"", cur->out_identdt);

		DBA_RUN_OR_RETURN(dba_seti(rec, "year_ident", year));
		DBA_RUN_OR_RETURN(dba_seti(rec, "month_ident", mon));
		DBA_RUN_OR_RETURN(dba_seti(rec, "day_ident", day));
		DBA_RUN_OR_RETURN(dba_seti(rec, "hour_ident", hour));
		DBA_RUN_OR_RETURN(dba_seti(rec, "min_ident", min));
	} 
	CHECKED_STORE(seti, height);
	CHECKED_STORE(seti, heightbaro);
	CHECKED_STORE(seti, block);
	CHECKED_STORE(seti, station);
	CHECKED_STORE(setc, name);
	return dba_error_ok();
}

dba_err dba_ana_cursor_next(dba_cursor cur, dba_record rec, int* is_last)
{
	assert(cur);
	assert(cur->db);
	assert(cur->type == ANA);

	/* Fetch new data */
	if (SQLFetch(cur->stm) == SQL_NO_DATA)
		return dba_error_notfound("retrieving a SQL query result (probably there are no more results to retrieve)");

	/* Check if this is the last value */
	*is_last = --cur->count == 0;

	/* Empty the record from old data */
	dba_record_clear(rec);

	/* Store the data into the record */
	DBA_RUN_OR_RETURN(dba_ana_cursor_to_rec(cur, rec));

	return dba_error_ok();
}

/* Buf must be at least 25 bytes long; values must be at least 6 ints long */
static dba_err parse_date_extreme(dba_record rec, char* names[], int* values)
{
	/* Compute the minimum date interval, if specified */
	char* s;
	int i, tail;
	
	for (i = 0, tail = 0; i < 6; i++)
	{
		/* Parse the values */
		const char* s = dba_record_enqk(rec, names[i]);
		if (s == NULL)
		{
			values[i] = -1;
			tail = 1;
		}
		else
		{
			if (tail)
				return dba_error_consistency("%s is unset but %s is set",
						names[i - 1], names[i]);
			values[i] = strtol(s, 0, 10);
		}
	}
	/* Now values is either 6 times -1, 6 values, or X values followed by 6-X times -1 */

	return dba_error_ok();
}

static int max_days(int y, int m)
{
	int days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
	if (m != 2)
		return days[m-1];
	else
		return (y % 4 == 0 && (y % 100 != 0 || y % 400 == 0)) ? 29 : 28;
}
 
static dba_err dba_prepare_select(dba db, dba_record rec, SQLHSTMT stm)
{
	int parm_num = 1;
	const char* val;

	/* Bind select fields */

#define PARM_INT(field, sql) do {\
	if ((val = dba_record_enqk(rec, #field)) != NULL) { \
		db->sel_##field = strtol(val, 0, 10); \
		TRACE("found " #field ": adding " sql ". val is %d\n", db->sel_##field); \
		strcat(db->querybuf, sql); \
		SQLBindParameter(stm, parm_num++, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0, &db->sel_##field, 0, 0); \
	} } while (0)

	/* Compute the minimum date interval, if specified */
	{
		char* names[] = { "yearmin", "monthmin", "daymin", "hourmin", "minumin", "secmin" };
		int values[6];
		DBA_RUN_OR_RETURN(parse_date_extreme(rec, names, values));

		/* Now values is either 6 times -1, 6 values, or X values followed by 6-X times -1 */

		if (values[0] != -1)
		{
			snprintf(db->sel_dtmin, 25, "%04d-%02d-%02d %02d:%02d:%02d",
					values[0],
					values[1] != -1 ? values[1] : 1,
					values[2] != -1 ? values[2] : 1,
					values[3] != -1 ? values[3] : 0,
					values[4] != -1 ? values[4] : 0,
					values[5] != -1 ? values[5] : 0);

			strcat(db->querybuf, " AND t.datetime >= ?");
			TRACE("found min time interval: adding AND t.datetime >= ?.  val is %s\n", db->sel_dtmin);
			SQLBindParameter(stm, parm_num++, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, 0, 0, (char*)db->sel_dtmin, 0, 0);
		}
	}

	/* Compute the maximum date interval, if specified */
	{
		char* names[] = { "yearmax", "monthmax", "daymax", "hourmax", "minumax", "secmax" };
		int values[6];
		DBA_RUN_OR_RETURN(parse_date_extreme(rec, names, values));

		/* Now values is either 6 times -1, 6 values, or X values followed by 6-X times -1 */

		if (values[0] != -1)
		{
			values[1] = values[1] != -1 ? values[1] : 12;
			values[2] = values[2] != -1 ? values[2] : max_days(values[0], values[1]);

			snprintf(db->sel_dtmax, 25, "%04d-%02d-%02d %02d:%02d:%02d",
					values[0], values[1], values[2],
					values[3] != -1 ? values[3] : 23,
					values[4] != -1 ? values[4] : 59,
					values[5] != -1 ? values[5] : 59);

			strcat(db->querybuf, " AND t.datetime <= ?");
			TRACE("found max time interval: adding AND t.datetime <= ?.  val is %s\n", db->sel_dtmax);
			SQLBindParameter(stm, parm_num++, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, 0, 0, (char*)db->sel_dtmax, 0, 0);
		}
	}

	/* Add datetimes with % */
	{
		char* names[] = { "yearmax", "monthmax", "daymax", "hourmax", "minumax", "secmax" };
		char* seps[] = { "-", "-", " ", ":", ":", "" };
		int i, c = 0, found = 0;

		/* Parse the values */
		for (i = 0; i < 6; i++)
		{
			const char* s = dba_record_enqk(rec, names[i]);
			if (s == NULL)
				c += snprintf(db->sel_dtlike + c, 25 - c, "%%%s", seps[i]);
			else
			{
				c += snprintf(db->sel_dtlike + c, 25 - c, "%04ld%s", strtol(s, 0, 10), seps[i]);
				found = 1;
			}
		}

		if (found)
		{
			strcat(db->querybuf, " AND t.datetime LIKE ?");
			TRACE("found time: adding AND t.datetime LIKE ?.  val is %s\n", db->sel_dtlike);
			SQLBindParameter(stm, parm_num++, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, 0, 0, (char*)db->sel_dtlike, 0, 0);
		}
	}

	PARM_INT(data_id, " AND d.id = ?");
	PARM_INT(ana_id, " AND pa.id = ?");
	PARM_INT(latmin, " AND pa.lat > ?");
	PARM_INT(latmax, " AND pa.lat < ?");
	PARM_INT(lonmin, " AND pa.lon > ?");
	PARM_INT(lonmax, " AND pa.lon < ?");

	{
		const char* mobile_sel = dba_record_enqk(rec, "mobile");
		const char* fixed_sel = dba_record_enqk(rec, "fixed");

		if (mobile_sel != NULL)
			if (fixed_sel != NULL)
				if (mobile_sel[0] == '1')
					db->sel_mobile = fixed_sel[0] == '1' ? -1 : 1;
				else
					if (fixed_sel[0] != '1')
						return dba_error_consistency("asked for stations which are neither mobile nor fixed (and quantum stations are not supported yet ;)");
					else
						db->sel_mobile = 0;
			else
				db->sel_mobile = mobile_sel[0] == '1' ? -1 : 0;
		else
			if (fixed_sel != NULL)
				db->sel_mobile = fixed_sel[0] == '1' ? -1 : 1;
			else
				db->sel_mobile = -1;
		
		if (db->sel_mobile != -1)
		{
			strcat(db->querybuf, " AND pa.mobile = ?");
			TRACE("found fixed/mobile: adding AND pa.mobile = ?. val is %d\n", db->sel_mobile);
			SQLBindParameter(stm, parm_num++, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0, &db->sel_mobile, 0, 0);
		}
	}

	PARM_INT(pindicator, " AND p.type = ?");
	PARM_INT(p1, " AND p.p1 = ?");
	PARM_INT(p2, " AND p.p2 = ?");
	PARM_INT(leveltype, " AND l.type = ?");
	PARM_INT(l1, " AND l.l1 = ?");
	PARM_INT(l2, " AND l.l2 = ?");

	if ((val = dba_record_enqk(rec, "var")) != NULL)
	{
		db->sel_b = dba_descriptor_code(val);
		TRACE("found b: adding AND d.id_var = ?. val is %d %s\n", db->sel_b, val);
		strcat(db->querybuf, " AND d.id_var = ?");
		SQLBindParameter(stm, parm_num++, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0, &db->sel_b, 0, 0);
	}
	if ((val = dba_record_enqk(rec, "varlist")) != NULL)
	{
		size_t pos;
		size_t len;
		TRACE("found blist: adding AND d.id_var IN (%s)\n", val);
		strcat(db->querybuf, " AND d.id_var IN (");
		for (pos = 0; (len = strcspn(val + pos, ",")) > 0; pos += len + 1)
		{
			dba_varcode code = DBA_STRING_TO_VAR(val + pos + 1);
			if (pos == 0)
				snprintf(db->querybuf + strlen(db->querybuf), 5, "%d", code);
			else
				snprintf(db->querybuf + strlen(db->querybuf), 6, ",%d", code);
		}
		strcat(db->querybuf, ")");
		/*
		strcat(db->querybuf, " AND d.id_var IN (?)");
		SQLBindParameter(stm, parm_num++, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, 0, 0, (char*)db->sel_blist, 0, 0);
		*/
	}

	PARM_INT(rep_cod, " AND ri.id = ?");

	if ((db->sel_ident = dba_record_enqk(rec, "ident")) != NULL)
	{
		strcat(db->querybuf, " AND pa.ident = ?");
		TRACE("found ident: adding AND pa.ident = ?.  val is %s\n", db->sel_ident);
		SQLBindParameter(stm, parm_num++, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, 0, 0, (char*)db->sel_ident, 0, 0);
	}

	if ((db->sel_rep_memo = dba_record_enqk(rec, "rep_memo")) != NULL)
	{
		strcat(db->querybuf, " AND ri.memo = ?");
		TRACE("found rep_memo: adding AND ri.memo = ?.  val is %s\n", db->sel_rep_memo);
		SQLBindParameter(stm, parm_num++, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, 0, 0, (char*)db->sel_rep_memo, 0, 0);
	}

	PARM_INT(priority, " AND ri.prio = ?");
	PARM_INT(priomin, " AND ri.prio >= ?");
	PARM_INT(priomax, " AND ri.prio <= ?");
	PARM_INT(block, " AND pa.block = ?");
	PARM_INT(station, " AND pa.station = ?");

	return dba_error_ok();

#undef PARM_INT
}


dba_err dba_query(dba db, dba_record rec, dba_cursor* cur, int* count)
{
	const char* query =
		"SELECT pa.id, pa.lat, pa.lon, pa.mobile, pa.ident, pa.identdt, pa.height, pa.heightbaro,"
		"       pa.block, pa.station, pa.name,"
		"       l.type, l.l1, l.l2,"
		"       p.type, p.p1, p.p2,"
		"       d.id_var, t.datetime, d.value, d.id_report, ri.memo, ri.prio, d.id"
		"  FROM pseudoana AS pa, levellayer AS l, timerange AS p, data AS d, repinfo AS ri, datetime AS t"
		" WHERE d.id_pseudoana = pa.id AND d.id_levellayer = l.id AND d.id_timerange = p.id"
		"   AND d.id_report = ri.id AND d.id_datetime = t.id";
	dba_err err;
	SQLHSTMT stm;
	int res;

	assert(db);

	/* Allocate a new cursor */
	DBA_RUN_OR_RETURN(dba_cursor_new(db, cur));

	/* Setup the new cursor */
	(*cur)->type = DATA;

	/* Allocate statement handle */
	res = SQLAllocHandle(SQL_HANDLE_STMT, db->od_conn, &stm);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
	{
		free(cur);
		return dba_error_odbc(SQL_HANDLE_STMT, stm, "Allocating new statement handle");
	}

	(*cur)->stm = stm;

	/* Write the SQL query */

	/* Initial query */
	strcpy(db->querybuf, query);

	/* Bind output fields */
#define DBA_QUERY_BIND(num, type, name) \
	SQLBindCol(stm, num, type, &(*cur)->out_##name, sizeof((*cur)->out_##name), &(*cur)->out_##name##_ind);
	DBA_QUERY_BIND(1, SQL_C_SLONG, ana_id);
	DBA_QUERY_BIND(2, SQL_C_SLONG, lat);
	DBA_QUERY_BIND(3, SQL_C_SLONG, lon);
	DBA_QUERY_BIND(4, SQL_C_SLONG, mobile);
	DBA_QUERY_BIND(5, SQL_C_CHAR, ident);
	DBA_QUERY_BIND(6, SQL_C_CHAR, identdt);
	DBA_QUERY_BIND(7, SQL_C_SLONG, height);
	DBA_QUERY_BIND(8, SQL_C_SLONG, heightbaro);
	DBA_QUERY_BIND(9, SQL_C_SLONG, block);
	DBA_QUERY_BIND(10, SQL_C_SLONG, station);
	DBA_QUERY_BIND(11, SQL_C_CHAR, name);
	DBA_QUERY_BIND(12, SQL_C_SLONG, leveltype);
	DBA_QUERY_BIND(13, SQL_C_SLONG, l1);
	DBA_QUERY_BIND(14, SQL_C_SLONG, l2);
	DBA_QUERY_BIND(15, SQL_C_SLONG, pindicator);
	DBA_QUERY_BIND(16, SQL_C_SLONG, p1);
	DBA_QUERY_BIND(17, SQL_C_SLONG, p2);
	DBA_QUERY_BIND(18, SQL_C_SLONG, idvar);
	DBA_QUERY_BIND(19, SQL_C_CHAR, datetime);
	DBA_QUERY_BIND(20, SQL_C_CHAR, value);
	/* DBA_QUERY_BIND(21, SQL_C_SLONG, rep_id); */
	DBA_QUERY_BIND(21, SQL_C_SLONG, rep_cod);
	DBA_QUERY_BIND(22, SQL_C_CHAR, rep_memo);
	DBA_QUERY_BIND(23, SQL_C_SLONG, priority);
	DBA_QUERY_BIND(24, SQL_C_SLONG, data_id);
#undef DBA_QUERY_BIND
	
	/* Add the select part */
	if ((err = dba_prepare_select(db, rec, stm)) != DBA_OK)
		goto dba_query_failed;

	if (dba_record_enqk(rec, "querybest") != NULL)
		strcat(db->querybuf, " GROUP BY d.id_var, d.id_pseudoana, d.id_levellayer, d.id_timerange, t.datetime HAVING ri.prio=MAX(ri.prio) ORDER BY d.id_pseudoana, t.datetime, l.type, l1, l2, d.id_timerange");
	else
		strcat(db->querybuf, " ORDER BY d.id_pseudoana, t.datetime, l.type, l1, l2, d.id_timerange, ri.prio");

/* 	strcat(db->querybuf, " ORDER BY ri.prio, d.id_report"); */
/* fprintf(stderr, "QUERY: %s\n", db->querybuf); */

	TRACE("Performing query: %s\n", db->querybuf);

	/* Perform the query */
	res = SQLExecDirect(stm, db->querybuf, SQL_NTS);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
	{
		err = dba_error_odbc(SQL_HANDLE_STMT, stm, "performing DBALLE query \"%s\"", db->querybuf);
		goto dba_query_failed;
	}

	/* Get the number of affected rows */
	{
		SQLINTEGER rowcount;
		res = SQLRowCount(stm, &rowcount);
		if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
		{
			err = dba_error_odbc(SQL_HANDLE_STMT, stm, "getting row count");
			goto dba_query_failed;
		}
		(*cur)->count = *count = rowcount;
	}

	/* Retrieve results will happen in dba_cursor_next() */

	/* Done.  No need to deallocate the statement, it will be done by
	 * dba_cursor_delete */
	return dba_error_ok();

	/* Exit point with cleanup after error */
dba_query_failed:
	dba_cursor_delete(*cur);
	*cur = 0;
	return err;
}


static dba_err dba_cursor_var_to_rec(dba_cursor cur, dba_record rec)
{
	assert(cur);
	assert(cur->db);
	/*assert(cur->out_rep_id != -1); */
	{
		char bname[7];
		snprintf(bname, 7, "B%02d%03d",
					DBA_VAR_X(cur->out_idvar),
					DBA_VAR_Y(cur->out_idvar));
		DBA_RUN_OR_RETURN(dba_setc(rec, "var", bname));
		DBA_RUN_OR_RETURN(dba_setc(rec, bname, cur->out_value));
		DBA_RUN_OR_RETURN(dba_setid(rec, cur->out_idvar, cur->out_data_id));
	}
	return dba_error_ok();
}
static dba_err dba_cursor_to_rec(dba_cursor cur, dba_record rec)
{
	assert(cur);
	assert(cur->db);
	/* assert(cur->out_rep_id != -1); */

	/* Copy the resulting data into `rec' */
	DBA_RUN_OR_RETURN(dba_ana_cursor_to_rec(cur, rec));

	CHECKED_STORE(seti, leveltype);
	CHECKED_STORE(seti, l1);
	CHECKED_STORE(seti, l2);
	CHECKED_STORE(seti, pindicator);
	CHECKED_STORE(seti, p1);
	CHECKED_STORE(seti, p2);
	if (cur->out_datetime_ind != SQL_NULL_DATA)
	{
		/*fprintf(stderr, "SETTING %s to %d\n", #var,  _db_cursor[cur].out_##var); */
		int year, mon, day, hour, min, sec;
		if (sscanf(cur->out_datetime,
					"%04d-%02d-%02d %02d:%02d:%02d", &year, &mon, &day, &hour, &min, &sec) != 6)
			return dba_error_consistency("parsing datetime string \"%s\"", cur->out_datetime);

		DBA_RUN_OR_RETURN(dba_setc(rec, "datetime", cur->out_datetime));
		DBA_RUN_OR_RETURN(dba_seti(rec, "year", year));
		DBA_RUN_OR_RETURN(dba_seti(rec, "month", mon));
		DBA_RUN_OR_RETURN(dba_seti(rec, "day", day));
		DBA_RUN_OR_RETURN(dba_seti(rec, "hour", hour));
		DBA_RUN_OR_RETURN(dba_seti(rec, "min", min));
		DBA_RUN_OR_RETURN(dba_seti(rec, "sec", sec));
	} 
	/* CHECKED_STORE(seti, rep_id); */
	CHECKED_STORE(seti, rep_cod);
	CHECKED_STORE(setc, rep_memo);
	CHECKED_STORE(seti, priority);
	CHECKED_STORE(seti, data_id);
	DBA_RUN_OR_RETURN(dba_cursor_var_to_rec(cur, rec));
	return dba_error_ok();
}

dba_err dba_cursor_next(dba_cursor cur, dba_record rec, dba_varcode* var, int* is_last)
{
	assert(cur);
	assert(cur->db);

	assert(cur->type == DATA);

	/* Fetch the first row */
	if (SQLFetch(cur->stm) == SQL_NO_DATA)
		return dba_error_notfound("retrieving a SQL query result (probably there are no more results to retrieve)");

	/* Empty the record from old data */
	dba_record_clear(rec);

	/* Store the data into the record */
	DBA_RUN_OR_RETURN(dba_cursor_to_rec(cur, rec));

	/* Store the database ID together with the value */
	DBA_RUN_OR_RETURN(dba_setid(rec, cur->out_idvar, cur->out_data_id));

	*is_last = --cur->count == 0;

	/* Store the variable ID */
	*var = cur->out_idvar;

	return dba_error_ok();
}
#undef CHECKED_STORE

void dba_cursor_delete(dba_cursor cur)
{
	assert(cur);
	assert(cur->db);

	SQLFreeHandle(SQL_HANDLE_STMT, cur->stm);
	free(cur);
}

#ifdef DBA_USE_DELETE_USING
dba_err dba_delete(dba db, dba_record rec)
{
	const char* query =
		"DELETE FROM data, qc"
		" USING pseudoana AS pa, levellayer AS l, timerange AS p, data AS d, repinfo AS ri, datetime AS t"
		"  LEFT JOIN qc AS qc ON qc.id_data = d.id"
		" WHERE d.id_pseudoana = pa.id AND d.id_levellayer = l.id AND d.id_timerange = p.id"
		"   AND d.id_report = ri.id AND d.id_datetime = t.id";
	dba_err err;
	SQLHSTMT stm;
	int res;

	assert(db);

	/* Allocate statement handle */
	res = SQLAllocHandle(SQL_HANDLE_STMT, db->od_conn, &stm);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
	{
		return dba_error_odbc(SQL_HANDLE_STMT, stm, "Allocating new statement handle");
	}

	/* Write the SQL query */

	/* Initial query */
	strcpy(db->querybuf, query);

	/* Bind select fields */
	if ((err = dba_prepare_select(db, rec, stm)) != DBA_OK)
		goto dba_delete_failed;

	/*fprintf(stderr, "QUERY: %s\n", db->querybuf);*/

	/* Perform the query */
	res = SQLExecDirect(stm, db->querybuf, SQL_NTS);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
	{
		err = dba_error_odbc(SQL_HANDLE_STMT, stm, "performing DBALLE query \"%s\"", db->querybuf);
		goto dba_delete_failed;
	}

	SQLFreeHandle(SQL_HANDLE_STMT, stm);
	return dba_error_ok();

	/* Exit point with cleanup after error */
dba_delete_failed:
	SQLFreeHandle(SQL_HANDLE_STMT, stm);
	return err;
}
#else
dba_err dba_delete(dba db, dba_record rec)
{
	const char* query =
		"SELECT d.id FROM pseudoana AS pa, levellayer AS l, timerange AS p, data AS d, repinfo AS ri, datetime AS t"
		" WHERE d.id_pseudoana = pa.id AND d.id_levellayer = l.id AND d.id_timerange = p.id"
		"   AND d.id_report = ri.id AND d.id_datetime = t.id";
	dba_err err;
	SQLHSTMT stm;
	SQLHSTMT stm1;
	SQLHSTMT stm2;
	SQLINTEGER id;
	int res;

	assert(db);

	/* Allocate statement handles */
	res = SQLAllocHandle(SQL_HANDLE_STMT, db->od_conn, &stm);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
	{
		return dba_error_odbc(SQL_HANDLE_STMT, stm, "Allocating new statement handle");
	}
	res = SQLAllocHandle(SQL_HANDLE_STMT, db->od_conn, &stm1);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
	{
		SQLFreeHandle(SQL_HANDLE_STMT, stm);
		return dba_error_odbc(SQL_HANDLE_STMT, stm1, "Allocating new statement handle");
	}
	res = SQLAllocHandle(SQL_HANDLE_STMT, db->od_conn, &stm2);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
	{
		SQLFreeHandle(SQL_HANDLE_STMT, stm);
		SQLFreeHandle(SQL_HANDLE_STMT, stm1);
		return dba_error_odbc(SQL_HANDLE_STMT, stm2, "Allocating new statement handle");
	}

	/* Write the SQL query */

	/* Initial query */
	strcpy(db->querybuf, query);

	/* Bind select fields */
	if ((err = dba_prepare_select(db, rec, stm)) != DBA_OK)
		goto dba_delete_failed;

	/* Bind output field */
	SQLBindCol(stm, 1, SQL_C_SLONG, &id, sizeof(id), NULL);

	/*fprintf(stderr, "QUERY: %s\n", db->querybuf);*/

	/* Perform the query */
	TRACE("Performing query %s\n", db->querybuf);
	res = SQLExecDirect(stm, db->querybuf, SQL_NTS);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
	{
		err = dba_error_odbc(SQL_HANDLE_STMT, stm, "performing DBALLE query \"%s\"", db->querybuf);
		goto dba_delete_failed;
	}

	/* Compile the DELETE query for the data */
	res = SQLPrepare(stm1, "DELETE FROM data WHERE id=?", SQL_NTS);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
	{
		err = dba_error_odbc(SQL_HANDLE_STMT, stm1, "compiling query to delete data entries");
		goto dba_delete_failed;
	}
	/* Bind parameters */
	SQLBindParameter(stm1, 1, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0, &id, 0, 0);

	/* Compile the DELETE query for the associated QC */
	res = SQLPrepare(stm2, "DELETE FROM qc WHERE id_data=?", SQL_NTS);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
	{
		err = dba_error_odbc(SQL_HANDLE_STMT, stm2, "compiling query to delete entries related to QC data");
		goto dba_delete_failed;
	}
	/* Bind parameters */
	SQLBindParameter(stm2, 1, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0, &id, 0, 0);

	/* Fetch the IDs and delete them */
	while (SQLFetch(stm) != SQL_NO_DATA)
	{
		/*fprintf(stderr, "Deleting %d\n", id);*/
		res = SQLExecute(stm1);
		if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
		{
			err = dba_error_odbc(SQL_HANDLE_STMT, stm1, "deleting entry %d from the 'data' table", id);
			goto dba_delete_failed;
		}
		res = SQLExecute(stm2);
		if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
		{
			err = dba_error_odbc(SQL_HANDLE_STMT, stm2, "deleting QC data related to 'data' entry %d", id);
			goto dba_delete_failed;
		}
	}

	SQLFreeHandle(SQL_HANDLE_STMT, stm);
	SQLFreeHandle(SQL_HANDLE_STMT, stm1);
	SQLFreeHandle(SQL_HANDLE_STMT, stm2);
	return dba_error_ok();

	/* Exit point with cleanup after error */
dba_delete_failed:
	SQLFreeHandle(SQL_HANDLE_STMT, stm);
	SQLFreeHandle(SQL_HANDLE_STMT, stm1);
	SQLFreeHandle(SQL_HANDLE_STMT, stm2);
	return err;
}
#endif

dba_err dba_qc_query(dba db, int id_data, dba_varcode* qcs, int qcs_size, dba_record qc, int* count)
{
	char query[100 + 100*6];
	SQLHSTMT stm;
	dba_err err;
	int res;
	int out_type;
	const char out_value[255];

	assert(db);

	/* Create the query */
	if (qcs == NULL)
		/* If qcs is null, query all QC data */
		strcpy(query,
				"SELECT q.type, q.value"
				"  FROM qc AS q, data AS d"
				" WHERE d.id = ? AND q.id_data = d.id");
	else {
		int i, qs;
		char* q;
		if (qcs_size > 100)
			return dba_error_consistency("checking bound of 100 QC values to retrieve per query");
		strcpy(query,
				"SELECT q.type, q.value"
				"  FROM qc AS q, data AS d"
				" WHERE d.id = ? AND q.id_data = d.id AND q.type IN (");
		qs = strlen(query);
		q = query + qs;
		for (i = 0; i < qcs_size; i++)
			if (q == query + qs)
				q += snprintf(q, 7, "%hd", qcs[i]);
			else
				q += snprintf(q, 8, ",%hd", qcs[i]);
		strcpy(q, ")");
	}

	/* Allocate statement handle */
	res = SQLAllocHandle(SQL_HANDLE_STMT, db->od_conn, &stm);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
		return dba_error_odbc(SQL_HANDLE_STMT, stm, "Allocating new statement handle");

	/* Bind input parameters */
	SQLBindParameter(stm, 1, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0, &id_data, 0, 0);

	/* Bind output fields */
	SQLBindCol(stm, 1, SQL_C_SLONG, &out_type, sizeof(out_type), 0);
	SQLBindCol(stm, 2, SQL_C_CHAR, &out_value, sizeof(out_value), 0);
	
	TRACE("QC read query: %s with id_data %d\n", query, id_data);

	/* Perform the query */
	res = SQLExecDirect(stm, (char*)query, SQL_NTS);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
	{
		err = dba_error_odbc(SQL_HANDLE_STMT, stm, "performing DBALLE query \"%s\"", query);
		goto dba_qc_query_failed;
	}

	/* Retrieve results */
	dba_record_clear(qc);

	/* Fetch new data */
	*count = 0;
	while (SQLFetch(stm) != SQL_NO_DATA)
	{
		char buf[7];
		sprintf(buf, "B%02d%03d", DBA_VAR_X(out_type), DBA_VAR_Y(out_type));
		dba_setc(qc, buf, out_value);		
		(*count)++;
	}

	SQLFreeHandle(SQL_HANDLE_STMT, stm);
	return dba_error_ok();

	/* Exit point with cleanup after error */
dba_qc_query_failed:
	SQLFreeHandle(SQL_HANDLE_STMT, stm);
	return err;
}

static dba_err dba_qc_get_data_id(dba db, dba_record rec, dba_varcode var, int* id_data)
{
	SQLHSTMT stm;
	int rep_id;
	SQLINTEGER id_data_ind;
	dba_err err;
	int res;

	/* The the value of rep_id from rec */
	DBA_RUN_OR_RETURN(dba_enqi(rec, "rep_id", &rep_id));

	/* Allocate statement handle */
	res = SQLAllocHandle(SQL_HANDLE_STMT, db->od_conn, &stm);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
	{
		dba_rollback(db->od_conn);
		return dba_error_odbc(SQL_HANDLE_STMT, stm, "Allocating new statement handle");
	}

	/* Get the id of the corresponding datum */
	/* id_data = SELECT id FROM data WHERE type = var and id_repo = rec.rep_id; */

	SQLBindParameter(stm, 1, SQL_PARAM_INPUT, SQL_C_USHORT, SQL_INTEGER, 0, 0, &var, 0, 0);
	SQLBindParameter(stm, 2, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0, &rep_id, 0, 0);

	/* Check for an existing data with these data */

	/* Bind variable and indicator for SELECT results */
	SQLBindCol(stm, 1, SQL_C_SLONG, id_data, sizeof(*id_data), &id_data_ind);
	
	/* Casting to char* because ODBC is unaware of const */
	res = SQLExecDirect(stm, "SELECT id FROM data WHERE id_var = ? and id_report = ?", SQL_NTS);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
	{
		err = dba_error_odbc(SQL_HANDLE_STMT, stm, "looking for existing data to connect to QC values");
		goto dba_qc_get_data_id_failed;
	}

	if (SQLFetch(stm) == SQL_NO_DATA)
	{
		err = dba_error_consistency("no data id obtained while looking for the id of var=%d and report=%d", var, rep_id);
		goto dba_qc_get_data_id_failed;
	}

	if (id_data_ind != sizeof(*id_data))
	{
		err = dba_error_consistency("checking that the size of the ID coming from the database is correct");
		goto dba_qc_get_data_id_failed;
	}

	SQLFreeHandle(SQL_HANDLE_STMT, stm);
	return dba_error_ok();

	/* Exits with cleanup after error */
dba_qc_get_data_id_failed:
	SQLFreeHandle(SQL_HANDLE_STMT, stm);
	return err;
}

dba_err dba_qc_insert_or_replace(dba db, int id_data, /*dba_record rec, dba_varcode var,*/ dba_record qc, int can_replace)
{
	const char* insert_query =
		"INSERT INTO qc (id_data, type, value)"
		" VALUES(?, ?, ?)";
	const char* replace_query =
		"REPLACE INTO qc (id_data, type, value)"
		" VALUES(?, ?, ?)";
	dba_err err;
	dba_record_cursor item;
#if 0
	int id_data;
#endif
	dba_varcode type;
	char value[255];
	SQLINTEGER value_ind;
	SQLHSTMT stm;
	int res;
	
	assert(db);

	/* Begin the transaction */
	DBA_RUN_OR_RETURN(dba_begin(db->od_conn));

	/* Allocate statement handle */
	res = SQLAllocHandle(SQL_HANDLE_STMT, db->od_conn, &stm);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
	{
		dba_rollback(db->od_conn);
		return dba_error_odbc(SQL_HANDLE_STMT, stm, "Allocating new statement handle");
	}

#if 0
	/* Get the id of the corresponding datum */
	/* DBA_RUN_OR_GOTO(dba_qc_insert_failed, dba_qc_get_data_id(db, rec, var, &id_data)); */
	DBA_RUN_OR_GOTO(dba_qc_insert_failed, dba_enqid(rec, var, &id_data));
#endif

	/* Compile the INSERT/UPDATE SQL query */
	/* Casting to char* because ODBC is unaware of const */
	res = SQLPrepare(stm, can_replace ? (char*)replace_query : (char*)insert_query, SQL_NTS);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
	{
		err = dba_error_odbc(SQL_HANDLE_STMT, stm, "compiling query to insert into 'qc'");
		goto dba_qc_insert_failed;
	}

	/* Bind parameters */
	SQLBindParameter(stm, 1, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0, &id_data, 0, 0);
	SQLBindParameter(stm, 2, SQL_PARAM_INPUT, SQL_C_USHORT, SQL_INTEGER, 0, 0, &type, 0, 0);
	SQLBindParameter(stm, 3, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, 0, 0, value, 0, &value_ind);
	
	/* Insert all found variables */
	for (item = dba_record_iterate_first(qc); item != NULL;
			item = dba_record_iterate_next(qc, item))
	{
		dba_var variable = dba_record_cursor_variable(item);
		const char* cur_value = dba_var_value(variable);

		/* Variable ID */
		type = dba_var_code(variable);

		/* Variable value */
		if ((value_ind = strlen(cur_value)) > 256)
			value_ind = 255;
		strncpy(value, cur_value, value_ind);
		value[value_ind] = 0;

		res = SQLExecute(stm);
		if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
		{
			err = dba_error_odbc(SQL_HANDLE_STMT, stm, "inserting new data into 'qc'");
			goto dba_qc_insert_failed;
		}
	}
			
	SQLFreeHandle(SQL_HANDLE_STMT, stm);
	if ((err = dba_commit(db->od_conn)))
	{
		dba_rollback(db->od_conn);
		return err;
	}
	return dba_error_ok();

	/* Exits with cleanup after error */
dba_qc_insert_failed:
	SQLFreeHandle(SQL_HANDLE_STMT, stm);
	dba_rollback(db->od_conn);
	return err;
}

dba_err dba_qc_insert(dba db, int id_data, /*dba_record rec, dba_varcode var,*/ dba_record qc)
{
	return dba_qc_insert_or_replace(db, id_data, /*rec, var,*/ qc, 1);
}

dba_err dba_qc_insert_new(dba db, int id_data, /*dba_record rec, dba_varcode var,*/ dba_record qc)
{
	return dba_qc_insert_or_replace(db, id_data, /*rec, var,*/ qc, 0);
}

dba_err dba_qc_delete(dba db, int id_data, dba_varcode* qcs, int qcs_size)
{
	char query[60 + 100*6];
	SQLHSTMT stm;
	dba_record_cursor item;
	dba_err err;
	int res;

	assert(db);

	// Create the query
	if (qcs == NULL)
		strcpy(query, "DELETE FROM qc WHERE id_data = ?");
	else {
		int i, qs;
		char* q;
		if (qcs_size > 100)
			return dba_error_consistency("checking bound of 100 QC values to delete per query");
		strcpy(query, "DELETE FROM qc WHERE id_data = ? AND type IN (");
		qs = strlen(query);
		q = query + qs;
		for (i = 0; i < qcs_size; i++)
			if (q == query + qs)
				q += snprintf(q, 7, "%hd", qcs[i]);
			else
				q += snprintf(q, 8, ",%hd", qcs[i]);
		strcpy(q, ")");
	}

	/* Allocate statement handle */
	res = SQLAllocHandle(SQL_HANDLE_STMT, db->od_conn, &stm);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
		return dba_error_odbc(SQL_HANDLE_STMT, stm, "Allocating new statement handle");

	/* Bind parameters */
	SQLBindParameter(stm, 1, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0, &id_data, 0, 0);

	TRACE("Performing query %s for id %d\n", query, id_data);
	
	/* Execute the DELETE SQL query */
	/* Casting to char* because ODBC is unaware of const */
	res = SQLExecDirect(stm, (char*)query, SQL_NTS);
	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO))
	{
		err = dba_error_odbc(SQL_HANDLE_STMT, stm, "deleting data from 'qc'");
		goto dba_qc_delete_failed;
	}
			
	SQLFreeHandle(SQL_HANDLE_STMT, stm);
	return dba_error_ok();

	/* Exits with cleanup after error */
dba_qc_delete_failed:
	SQLFreeHandle(SQL_HANDLE_STMT, stm);
	return err;
}


#if 0
	{
		/* List DSNs */
		char dsn[100], desc[100];
		short int len_dsn, len_desc, next;

		for (next = SQL_FETCH_FIRST;
				SQLDataSources(pc.od_env, next, dsn, sizeof(dsn),
					&len_dsn, desc, sizeof(desc), &len_desc) == SQL_SUCCESS;
				next = SQL_FETCH_NEXT)
			printf("DSN %s (%s)\n", dsn, desc);
	}
#endif

#if 0
	for (res = SQLFetch(pc.od_stm); res != SQL_NO_DATA; res = SQLFetch(pc.od_stm))
	{
		printf("Result: %d\n", i);
	}
#endif



#include <dballe/dba_check.h>

#ifdef HAVE_CHECK
#include <stdio.h>
#include <unistd.h>

/*
{
	dba_item item;
	fprintf(stderr, "Record:\n");
	for (item = dba_record_iterate_first(result); item != NULL;
			item = dba_record_iterate_next(result, item))
		fprintf(stderr, "\t %s: %s\n", item->param, item->value);
}
*/

struct test_data
{
	const char* key;
	const char* val;
};

static struct test_data tdata0_ana[] = {
	{ "lat", "1234560" },
	{ "lon", "7654320" },
	{ "mobile", "0" },
	{ "year_ident", "2003" },
	{ "month_ident", "3" },
	{ "day_ident", "23" },
	{ "hour_ident", "12" },
	{ "min_ident", "30" },
	{ "height", "42" },
	{ "heightbaro", "234" },
	{ "block", "1" },
	{ "station", "52" },
	{ "name", "Cippo Lippo" },
};

static struct test_data tdata0[] = {
	{ "year", "1945" },
	{ "month", "4" },
	{ "day", "25" },
	{ "hour", "8" },
	{ "leveltype", "10" },
	{ "l1", "11" },
	{ "l2", "22" },
	{ "pindicator", "20" },
	{ "p1", "111" },
};

static struct test_data tdata1_patch0[] = {
	{ "min", "0" },
	{ "p2", "122" },
	{ "B01093", "Hey Hey Hey" },
	{ "rep_cod", "1" },
	{ "priority", "100" },
};
static struct test_data tdata1_patch1[] = {
	{ "min", "0" },
	{ "p2", "122" },
	{ "B01023", "500" },
	{ "rep_cod", "1" },
	{ "priority", "100" },
};

static struct test_data tdata2_patch0[] = {
	{ "min", "30" },
	{ "p2", "123" },
	{ "B01093", "Ho Ho Ho Hey" },
	{ "rep_cod", "2" },
	{ "priority", "80" },
};
static struct test_data tdata2_patch1[] = {
	{ "min", "30" },
	{ "p2", "123" },
	{ "B01023", "600" },
	{ "rep_cod", "2" },
	{ "priority", "80" },
};

static struct test_data tdata3_patch[] = {
	{ "mobile", "1" },
	{ "ident", "Cippo" },
};

#define FILLREC(rec, data) do { \
		int i; \
		for (i = 0; i < sizeof(data) / sizeof(struct test_data); i++) \
			CHECKED(dba_setc(rec, data[i].key, data[i].val)); \
	} while(0)

#define CHECKREC(rec, data) do { \
		int i; \
		const char* sval; \
		for (i = 0; i < sizeof(data) / sizeof(struct test_data); i++) { \
			CHECKED(dba_enqc(rec, data[i].key, &sval)); \
			if (strcmp(sval, data[i].val) != 0) \
			{ \
				static char buf[200]; \
				snprintf(buf, 200, "%s is %s instead of %s", data[i].key, sval, data[i].val); \
				_fail_unless(0, __FILE__, __LINE__, "Failed", buf, NULL); \
			} \
		} \
	} while(0)
				// _fail_unless(0, __FILE__, __LINE__, buf, "strcmp(sval, data[i].val) != 0)", NULL); 

static void printrecord(dba_record rec, const char* prefix)
{
	dba_record_cursor item;

	for (item = dba_record_iterate_first(rec); item != NULL;
			item = dba_record_iterate_next(rec, item))
	{
		dba_var var = dba_record_cursor_variable(item);
		dba_varcode code = dba_var_code(var);
		fprintf(stderr, "%s B%02d%03d->%s\n", prefix,
				DBA_VAR_X(code), DBA_VAR_Y(code),
				dba_var_value(var));
	}
}

static void crash(void* data)
{
	print_dba_error();
	abort();
}

void test_dballe(const char* dsn, const char* user, const char* pass)
{
	dba_record insert;
	dba_record query;
	dba_record result;
	dba_record qc;
	dba db;

	/*dba_error_set_callback(DBA_ERR_NONE, crash, 0);*/

	/* Test a dballe session */
	CHECKED(dba_init());
	CHECKED(dba_open(dsn, user, pass, &db));
	CHECKED(dba_reset(db, 0));

	/* Create the records we use to work */
	CHECKED(dba_record_create(&insert));
	CHECKED(dba_record_create(&query));
	CHECKED(dba_record_create(&result));
	CHECKED(dba_record_create(&qc));


	/* Fill in some data */
	FILLREC(insert, tdata0_ana);
	FILLREC(insert, tdata0);
	FILLREC(insert, tdata1_patch0);
	FILLREC(insert, tdata1_patch1);

	/* Insert the record */
	CHECKED(dba_insert_new(db, insert));
	/* Check if duplicate updates are allowed by insert */
	CHECKED(dba_insert(db, insert));
	/* Check if duplicate updates are trapped by insert_new */
	fail_unless(dba_insert_new(db, insert) == DBA_ERROR);

	/* Insert another record (similar but not the same) */
	FILLREC(insert, tdata2_patch0);
	FILLREC(insert, tdata2_patch1);
	CHECKED(dba_insert_new(db, insert));
	/* Check if duplicate updates are trapped */
	fail_unless(dba_insert_new(db, insert) == DBA_ERROR);

	/* Check dba_ana_* functions */
	{
		int is_last;
		int count = 0;
		dba_cursor cursor;

		/*
		CHECKED(dba_ana_count(db, &count));
		fail_unless(count == 1);
		*/

		/* Iterate the anagraphic database */
		CHECKED(dba_ana_query(db, &cursor, &count));
		fail_unless(count == 1);

		/* There should be an item */
		CHECKED(dba_ana_cursor_next(cursor, result, &is_last));

		/* Check that the results match */
		CHECKREC(result, tdata0_ana);

		/* There should be only one item */
		fail_unless(is_last);

		fail_unless(dba_ana_cursor_next(cursor, result, &is_last) == DBA_ERROR);

		dba_cursor_delete(cursor);
	}

	/* Try many possible queries */

#define TRY_QUERY(type, param, value) do {\
		int count; \
		dba_cursor cursor; \
		dba_record_clear(query); \
		CHECKED(dba_set##type(query, param, value)); \
		CHECKED(dba_query(db, query, &cursor, &count)); \
		fail_unless(cursor != 0); \
		dba_cursor_delete(cursor); \
	} while (0)

	TRY_QUERY(c, "ana_id", "1");
	TRY_QUERY(i, "yearmin", 1999);
	TRY_QUERY(i, "yearmax", 2030);
	TRY_QUERY(i, "year", 2005);
	/*
	TRY_QUERY(i, "monthmin", 1);
	TRY_QUERY(i, "monthmax", 12);
	*/
	TRY_QUERY(i, "month", 5);
	/*
	TRY_QUERY(i, "daymin", 1);
	TRY_QUERY(i, "daymax", 12);
	*/
	TRY_QUERY(i, "day", 5);
	/*
	TRY_QUERY(i, "hourmin", 1);
	TRY_QUERY(i, "hourmax", 12);
	*/
	TRY_QUERY(i, "hour", 5);
	/*
	TRY_QUERY(i, "minumin", 1);
	TRY_QUERY(i, "minumax", 12);
	*/
	TRY_QUERY(i, "min", 5);
	/*
	TRY_QUERY(i, "secmin", 1);
	TRY_QUERY(i, "secmax", 12);
	*/
	TRY_QUERY(i, "sec", 5);
	TRY_QUERY(i, "latmin", 1);
	TRY_QUERY(i, "latmax", 60);
	TRY_QUERY(i, "lonmin", 1);
	TRY_QUERY(i, "lonmax", 60);
	TRY_QUERY(i, "mobile", 1);
	TRY_QUERY(i, "fixed", 1);
	//TRY_QUERY(c, "ident_select", "pippo");
	TRY_QUERY(i, "pindicator", 1);
	TRY_QUERY(i, "p1", 1);
	TRY_QUERY(i, "p2", 1);
	TRY_QUERY(i, "leveltype", 1);
	TRY_QUERY(i, "l1", 1);
	TRY_QUERY(i, "l2", 1);
	TRY_QUERY(c, "var", "B10020");
	TRY_QUERY(i, "rep_cod", 1);
	TRY_QUERY(i, "priority", 1);
	TRY_QUERY(i, "priomin", 1);
	TRY_QUERY(i, "priomax", 1);
	TRY_QUERY(i, "station", 1);

	/* Try a query */
	{
		int count;
		int is_last;
		dba_varcode var;
		dba_cursor cursor;

		dba_record_clear(query);

		/* Prepare a query */
		CHECKED(dba_seti(query, "latmin", 1000000));

		/* Make the query */
		CHECKED(dba_query(db, query, &cursor, &count));

		/* See that a cursor has in fact been allocated */
		fail_unless(cursor != 0);

		/* There should be at least one item */
		CHECKED(dba_cursor_next(cursor, result, &var, &is_last));
		fail_unless(!is_last);

		/* Check that the results match */
		CHECKREC(result, tdata0_ana);
		CHECKREC(result, tdata0);

		/*
		printrecord(result, "RES: ");
		exit(0);
		*/

		fail_unless(var == DBA_VAR(0, 1, 93) || var == DBA_VAR(0, 1, 23));
		if (var == DBA_VAR(0, 1, 93))
			CHECKREC(result, tdata1_patch0);
		if (var == DBA_VAR(0, 1, 23))
			CHECKREC(result, tdata1_patch1);

		/* The item should have two data in it */
		CHECKED(dba_cursor_next(cursor, result, &var, &is_last));

		fail_unless(var == DBA_VAR(0, 1, 93) || var == DBA_VAR(0, 1, 23));
		if (var == DBA_VAR(0, 1, 93))
			CHECKREC(result, tdata1_patch0);
		if (var == DBA_VAR(0, 1, 23))
			CHECKREC(result, tdata1_patch1);

		/* There should be also another item */
		CHECKED(dba_cursor_next(cursor, result, &var, &is_last));

		/* Check that the results matches */
		CHECKREC(result, tdata0_ana);
		CHECKREC(result, tdata0);

		fail_unless(var == DBA_VAR(0, 1, 93) || var == DBA_VAR(0, 1, 23));
		if (var == DBA_VAR(0, 1, 93))
			CHECKREC(result, tdata2_patch0);
		if (var == DBA_VAR(0, 1, 23))
			CHECKREC(result, tdata2_patch1);

		/* The item should have two data in it */
		CHECKED(dba_cursor_next(cursor, result, &var, &is_last));

		fail_unless(var == DBA_VAR(0, 1, 93) || var == DBA_VAR(0, 1, 23));
		if (var == DBA_VAR(0, 1, 93))
			CHECKREC(result, tdata2_patch0);
		if (var == DBA_VAR(0, 1, 23))
			CHECKREC(result, tdata2_patch1);

		/* Now there should not be anything anymore */
		fail_unless(is_last);
		fail_unless(dba_cursor_next(cursor, result, &var, &is_last) == DBA_ERROR);

		/* Deallocate the cursor */
		dba_cursor_delete(cursor);
	}

	/* Try a query for best value */
	{
		int count;
		int is_last;
		dba_varcode var;
		dba_cursor cursor;

		dba_record_clear(query);

		/* Prepare a query */
		CHECKED(dba_seti(query, "latmin", 1000000));
		CHECKED(dba_setc(query, "querybest", "1"));

		/* Make the query */
		CHECKED(dba_query(db, query, &cursor, &count));

		/* See that a cursor has in fact been allocated */
		fail_unless(cursor != 0);

		/* There should be four items */
		CHECKED(dba_cursor_next(cursor, result, &var, &is_last));
		fail_unless(!is_last);
		CHECKED(dba_cursor_next(cursor, result, &var, &is_last));
		fail_unless(!is_last);
		CHECKED(dba_cursor_next(cursor, result, &var, &is_last));
		fail_unless(!is_last);
		CHECKED(dba_cursor_next(cursor, result, &var, &is_last));

		/* Now there should not be anything anymore */
		fail_unless(is_last);
		fail_unless(dba_cursor_next(cursor, result, &var, &is_last) == DBA_ERROR);

		/* Deallocate the cursor */
		dba_cursor_delete(cursor);
	}


	/* Delete one of the items */
	dba_record_clear(query);
	CHECKED(dba_seti(query, "yearmin", 1945));
	CHECKED(dba_seti(query, "monthmin", 4));
	CHECKED(dba_seti(query, "daymin", 25));
	CHECKED(dba_seti(query, "hourmin", 8));
	CHECKED(dba_seti(query, "minumin", 10));
	CHECKED(dba_delete(db, query));

#if 0
	/* Querying for both exact time and a time range should fail */
	{
		int count;
		dba_cursor cursor;
		CHECKED(dba_seti(query, "min", 10));
		fail_unless(dba_query(db, query, &cursor, &count) == DBA_ERROR);
		/*
		 * No need to delete, as dba_query failed 
		dba_cursor_delete(cursor);
		 */
	}
#endif

	/* See if the results change after deleting the tdata2 item */
	{
		int count;
		int is_last;
		dba_varcode var;
		dba_cursor cursor;
		dba_record_clear(query);
		CHECKED(dba_seti(query, "latmin", 1000000));
		CHECKED(dba_query(db, query, &cursor, &count));
		fail_unless(count > 0);
		CHECKED(dba_cursor_next(cursor, result, &var, &is_last));
		CHECKREC(result, tdata0_ana);
		CHECKREC(result, tdata0);

		fail_unless(var == DBA_VAR(0, 1, 93) || var == DBA_VAR(0, 1, 23));
		if (var == DBA_VAR(0, 1, 93))
			CHECKREC(result, tdata1_patch0);
		if (var == DBA_VAR(0, 1, 23))
			CHECKREC(result, tdata1_patch1);

		/* The item should have two data in it */
		CHECKED(dba_cursor_next(cursor, result, &var, &is_last));

		fail_unless(var == DBA_VAR(0, 1, 93) || var == DBA_VAR(0, 1, 23));
		if (var == DBA_VAR(0, 1, 93))
			CHECKREC(result, tdata1_patch0);
		if (var == DBA_VAR(0, 1, 23))
			CHECKREC(result, tdata1_patch1);

		fail_unless(is_last);
		fail_unless(dba_cursor_next(cursor, result, &var, &is_last) == DBA_ERROR);
		dba_cursor_delete(cursor);
	}

	/* Insert some QC data */
	{
		int count;
		int is_last;
		dba_varcode var;
		dba_cursor cursor;
		int val;
		int qc_count;
		int id_data;

		dba_record_clear(query);
		CHECKED(dba_seti(query, "latmin", 1000000));
		CHECKED(dba_query(db, query, &cursor, &count));
		do {
			CHECKED(dba_cursor_next(cursor, result, &var, &is_last));
			/* fprintf(stderr, "%d B%02d%03d\n", count, DBA_VAR_X(var), DBA_VAR_Y(var)); */
		} while (!is_last && var != DBA_VAR(0, 1, 93));
		fail_unless(var == DBA_VAR(0, 1, 93));
		dba_cursor_delete(cursor);

		/* Insert new QC data about this report */
		dba_record_clear(qc);
		dba_seti(qc, "B30001", 11);
		dba_seti(qc, "B30002", 22);
		dba_seti(qc, "B30004", 33);
		dba_enqid(result, DBA_VAR(0, 1, 93), &id_data);
		CHECKED(dba_qc_insert(db, id_data, /*result, DBA_VAR(0, 1, 93),*/ qc));

		/* Query back the data */
		dba_record_clear(qc);
		CHECKED(dba_qc_query(db, id_data, NULL, 0, qc, &qc_count));

		CHECKED(dba_enqi(qc, "B30001", &val));
		fail_unless(val == 11);
		CHECKED(dba_enqi(qc, "B30002", &val));
		fail_unless(val == 22);
		CHECKED(dba_enqi(qc, "B30004", &val));
		fail_unless(val == 33);

		/* Delete a couple of items */
		{
			dba_varcode todel[] = {DBA_VAR(0, 30, 1), DBA_VAR(0, 30, 4)};
			CHECKED(dba_qc_delete(db, id_data, todel, 2));
		}
		/* Deleting non-existing items should not fail.  Also try creating a
		 * query with just on item */
		{
			dba_varcode todel[] = {DBA_VAR(0, 30, 1)};
			CHECKED(dba_qc_delete(db, id_data, todel, 1));
		}

		/* Query back the data */
		dba_record_clear(qc);
		{
			dba_varcode toget[] = { DBA_VAR(0, 30, 1), DBA_VAR(0, 30, 2), DBA_VAR(0, 30, 4) };
			CHECKED(dba_qc_query(db, id_data, toget, 3, qc, &qc_count));
		}

		fail_unless(dba_enqi(qc, "B30001", &val) == DBA_ERROR);
		CHECKED(dba_enqi(qc, "B30002", &val));
		fail_unless(val == 22);
		fail_unless(dba_enqi(qc, "B30004", &val) == DBA_ERROR);
	}

#if 0
	{
		/* Insert some many things */
		int i;
		for (i = 20; i < 10000; i++)
		{
			CHECKED(dba_seti(rec, "B01050", i));
			CHECKED(dba_seti(rec, "l1", i));
			CHECKED(dba_insert(db, rec));
		}
	}
#endif

	dba_record_delete(qc);
	dba_record_delete(insert);
	dba_record_delete(query);
	dba_record_delete(result);

	CHECKED(dba_close(db));
	CHECKED(dba_shutdown());

	/*dba_error_remove_callback(DBA_ERR_NONE, crash, 0);*/
}

#endif

/* vim:set ts=4 sw=4: */
