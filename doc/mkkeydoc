#!/usr/bin/python3

import textwrap
import argparse
import sys
import os
from collections import OrderedDict
from itertools import zip_longest
import logging

log = logging.getLogger()

# The values are:
#   required/optional/ignored on insert
#   required/optional/ignored on query
#   present/absent            on results
#   comment about the field  [optional value]
comments = OrderedDict((
    ("priority", [ "ignored", "optional", "present",
                  "Every type of report has an associated priority that controls "
                  "which data are first returned when there is more than one in the "
                  "same physical space.  It can be changed by editing "
                  "/etc/dballe/repinfo.csv"]),
    ("priomax",  [ "ignored", "optional", "absent" ]),
    ("priomin",  [ "ignored", "optional", "absent" ]),
    ("rep_memo", [ "required", "optional", "present" ]),
    ("ana_id",   [ "optional", "optional", "present",
                  "Internal DB-ALLe ID referring to a pseudoana entry, used as "
                  "a shortcut reference instead of specifying the full data" ]),
    ("block",    [ "optional", "optional", "present" ]),
    ("station",  [ "optional", "optional", "present" ]),
    ("mobile",   [ "required", "optional", "present",
                  "Set to 1 if the station is mobile, such as a ship or a flight; else 0"]),
    ("ident",    [ "required if mobile=1", "optional", "present if mobile=1" ]),
    ("name",     [ "optional", "optional", "present" ]),
    ("lat",      [ "required", "optional", "present", "on insert, it has priority over ana_id" ]),
    ("lon",      [ "required", "optional", "present", "on insert, it has priority over ana_id" ]),
    ("latmax",   [ "ignored", "optional", "absent" ]),
    ("latmin",   [ "ignored", "optional", "absent" ]),
    ("lonmax",   [ "ignored", "optional", "absent" ]),
    ("lonmin",   [ "ignored", "optional", "absent" ]),
    ("height",   [ "optional", "optional", "present" ]),
    ("heightbaro", [ "optional", "optional", "present" ]),
    ("year_ident", [ "required if mobile=1", "optional", "present if mobile=1",
                    "Only needed when the station is mobile"]),
    ("month_ident", [ "required if mobile=1", "optional", "present if mobile=1",
                     "Only needed when the station is mobile"]),
    ("day_ident", [ "required if mobile=1", "optional", "present if mobile=1",
                   "Only needed when the station is mobile"]),
    ("hour_ident", [ "required if mobile=1", "optional", "present if mobile=1",
                    "Only needed when the station is mobile"]),
    ("min_ident", [ "required if mobile=1", "optional", "present if mobile=1",
                   "Only needed when the station is mobile"]),
#   "datetime", [ "ignored", "ignored", "present",
#                     "Convenience parameter: after a query it contains the datetime informations ",
#             " all in a single string"],
    ("year",     [ "required", "optional", "present" ]),
    ("month",    [ "required", "optional", "present" ]),
    ("day",      [ "required", "optional", "present" ]),
    ("hour",     [ "required", "optional", "present" ]),
    ("min",      [ "required", "optional", "present" ]),
    ("sec",      [ "required", "optional", "present" ]),
    ("yearmax",  [ "ignored", "optional", "absent" ]),
    ("yearmin",  [ "ignored", "optional", "absent" ]),
    ("monthmax", [ "ignored", "optional", "absent" ]),
    ("monthmin", [ "ignored", "optional", "absent" ]),
    ("daymax",   [ "ignored", "optional", "absent" ]),
    ("daymin",   [ "ignored", "optional", "absent" ]),
    ("hourmax",  [ "ignored", "optional", "absent" ]),
    ("hourmin",  [ "ignored", "optional", "absent" ]),
    ("minumax",  [ "ignored", "optional", "absent" ]),
    ("minumin",  [ "ignored", "optional", "absent" ]),
    ("secmax",   [ "ignored", "optional", "absent" ]),
    ("secmin",   [ "ignored", "optional", "absent" ]),
    ("leveltype", [ "required", "optional", "present" ]),
    ("l1",       [ "required", "optional", "present" ]),
    ("l2",       [ "required", "optional", "present" ]),
    ("pindicator",   [ "required", "optional", "present" ]),
    ("p1",       [ "required", "optional", "present" ]),
    ("p2",       [ "required", "optional", "present" ]),
    ("var",      [ "ignored", "optional", "present, indicates the name of the last variable returned" ]),
    ("varlist",  [ "ignored", "optional", "absent",
              "Comma-separated list of variable codes wanted on output" ]),
    ("query",    [ "ignored", "optional", "absent",
              "Comma-separated list of query modifiers.  Can have one of: "
              "'best', 'bigana', 'nosort', 'stream'.  "
              "Examples: 'best', 'nosort,stream'" ]),
    ("ana_filter",   [ "ignored", "optional", "absent",
              "Restricts the results to only those stations which "
              "have a pseudoana value that matches the filter. "
              "Examples: 'height>=1000', 'B02001=1', '1000<=height<=2000" ]),
    ("data_filter",  [ "ignored", "optional", "absent",
              "Restricts the results to only the variables of the given type, which "
              "have a value that matches the filter. "
              "Examples: 't<260', 'B22021>2', '10<=B22021<=20'" ]),
    ("attr_filter",  [ "ignored", "optional", "absent",
              "Restricts the results to only those data which "
              "have an attribute that matches the filter. "
              "Examples: 'conf>70', 'B33197=0', '25<=conf<=50'" ]),
    ("limit",    [ "ignored", "optional", "absent",
              "Maximum number of results to return" ]),
))

def read_data():
    data = []
    for line in sys.stdin:
        line = line.strip()
        res = line.split(",")
        res[2] = int(res[2])
        res[3] = int(res[3])
        data.append(res)
    return data

def mkformat(unit, sz, dec):
    if  "CHARACTER" in unit or "CODE TABLE" in unit:
        return "{} chars".format(sz)
    elif dec == 0:
        return "{} digits".format(sz)
    else:
        return ('#' * (sz - dec)) + '.' + ('#' * dec)

def print_doxygen(data):
    print("""/**@defgroup dba_record_keywords Keywords used by dballe::Record
@ingroup tables

This table lists the keywords used by dballe::Record.  You can use them to query
and set data using function such as Record::enq() and Record::set().

Every keyword is listed together with its measure unit, length in characters or
digits and description.

\\verbatim
""")

    colsizes = (13, 9, 13, 53)
    titles = ("Name", "Unit", "Format", "Description")
    desc_wrapper = textwrap.TextWrapper(width=53)

    cols = []
    for sz, title in zip(colsizes, titles):
        cols.append(title.ljust(sz))
    print(" ".join(cols))

    for tag, unit, sz, dec, desc in data:
        #com = comments.get(tag, "")
        format = mkformat(unit, sz, dec)

        for d in desc_wrapper.wrap(desc):
            cols = []
            for sz, val in zip(colsizes, (tag, unit, format, d)):
                cols.append(val.ljust(sz))
            print(" ".join(cols))

    print()
    print("\\endverbatim")
    print("*/")

def print_markdown(data):
    print("# Input/output/query parameters")
    print()

    colsizes = (13, 9, 10, 27, 9, 8, 10, 31)
    titles = ("Name", "Unit", "Format", "Description", "On insert", "On query", "On results", "Comment")
    wrappers = [textwrap.TextWrapper(width=sz) for sz in colsizes]

    cols = []
    for sz, title in zip(colsizes, titles):
        cols.append(title.ljust(sz))
    print("|", " | ".join(cols), "|")

    cols = []
    for sz in colsizes:
        cols.append("-" * sz)
    print("|", " | ".join(cols), "|")


    for tag, unit, sz, dec, desc in data:
        info = comments.get(tag, None)
        if info is None:
            ins = que = res = com = ""
        else:
            ins, que, res, com = info + ([""] * (4 - len(info)))

        format = mkformat(unit, sz, dec)

        cols = [tag, unit, format, desc, ins, que, res, com]
        row = []
        for sz, val in zip(colsizes, cols):
            row.append(val.ljust(sz))
        print("|", " | ".join(row), "|")


def main():
    parser = argparse.ArgumentParser(description="Format dballe keywords for documentation.")
    parser.add_argument("outtype", help="output type")
    parser.add_argument("-v", "--verbose", action="store_true", help="verbose output")
    parser.add_argument("--debug", action="store_true", help="verbose output")

    args = parser.parse_args()

    FORMAT = "%(asctime)-15s %(levelname)s %(message)s"
    if args.debug:
        logging.basicConfig(level=logging.DEBUG, stream=sys.stderr, format=FORMAT)
    elif args.verbose:
        logging.basicConfig(level=logging.INFO, stream=sys.stderr, format=FORMAT)
    else:
        logging.basicConfig(level=logging.WARN, stream=sys.stderr, format=FORMAT)

    data = read_data()

    if args.outtype == "dox":
        print_doxygen(data)
    elif args.outtype == "md":
        print_markdown(data)

if __name__ == "__main__":
    main()
