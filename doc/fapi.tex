%
% Editorial notes are found in the 'Introduction' chapter, marked with a
% comment to find them more easily
%

%\documentclass[draft,a4paper]{book}
%\documentclass[final,a4wide]{book}
%\documentclass[final,12pt,a4paper,twoside]{book}
\documentclass[final,12pt,a4paper,twoside]{book}
%\usepackage[italian]{babel}
\usepackage[ascii]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{moreverb}
\usepackage{ifthen}
% Include alcuni simboli non pi√∫ standard ma usati da gnuplot
\usepackage{subfigure}
\usepackage{epsfig}
\usepackage{longtable}

\title{DB-ALLe Guide of the Fortran API}
\author{Enrico Zini \hfil {\tt enrico@enricozini.com}}

% Copyright: GNU GPL v2 or later.

\newcommand{\dballe}{{\tt DB-ALLe}}

\newcommand{\srcinsert}[1]{%
{\scriptsize
\verbatimtabinput[4]{#1}
}}

%\newlength{\savedmarginparwidth}
\newcommand{\figures}[2][!]{%
\smallskip
%\setlength{\savedmarginparwidth}{\marginparwidth}
%\setlength{\marginparwidth}{0pt}
\begin{minipage}[c]{\textwidth}
\ifthenelse{\equal{#1}{!}}{}{#1:\\}
#2
\end{minipage}
\medskip
%\setlength{\marginparwidth}{\savedmarginparwidth}
}

\makeindex

\begin{document}
\setlength{\oddsidemargin}{0pt}
\setlength{\evensidemargin}{0pt}
\bibliographystyle{plain}

\maketitle

%\begin{abstract}
%This document is a quick introduction to the Fortran API of DB-ALLe.  It
%proceeds step by step to introducing different parts of the library using
%commented example code.
%\end{abstract}

\tableofcontents
%\listoffigures
%\listoftables

\chapter {Introduction}
\label{ch-intro}

\dballe{} is a fast, temporary, on-disk database where meteorological data can
be stored, searched, retrieved and updated.  To make computation easier, data
is stored as physical data, that is, as measures of a variable in a specific
point of space and time, rather than as a sequence of reports.

This is a quick introduction to \dballe{}.  It is intended as a quick read to
get up to speed, and as a quick reference for everyday use.

% Editorial notes

This guide contains examples for all routines, plus examples for all known
common usage patterns of dballe.  Also, commented Fortran code is preferred
to long explanations whenever it makes sense.

Other documentation can be found in \cite{UserGuide} and \cite{LibDoc}.

\chapter {Basic concepts}
\label{ch-concepts}

\section{Connections, sessions and handles}

\dballe{} stores meteorological values in a database.  This database can be
optionally shared or accessed using the network.

You contact \dballe{} by creating a \emph{connection}, and you work in
\dballe{} using one or more \emph{sessions}.  A connection is an established
link between your program and \dballe{}, and you usually open it at the
beginning of your work and close it at the end.

Within a connection you can create many working sessions.  This is very useful
because it allows to do different things at the same time, like reading a set
of values while writing computed results.

You can also set some safety features on sessions: for example, when you create
a session for reading values you can set it to disable all writes, which helps
you catch some programming mistakes.

You refer to the connection and the sessions using \emph{handles}.  A handle is
just an integer value that you use when you need to refer to something that is
not otherwise representable in any Fortran data type.

When you create a connection or a session, \dballe{} will give you the integer
handle that you will later use to refer to it.

\section {Pseudoana}

Values in \dballe{} are associated to informations about their source, such as
what kind of station generated the data and some characteristics of the station.

These informations are called \emph{pseudoana} informations, to suggest that
they are something similar to anagraphical informations about the sources of
the values.

A pseudoana entry is uniquely identified by:

\begin{itemize}
\item \emph{latitude}.
\item \emph{longitude}.
\item \emph{station identifier} (if the station is mobile).
\end{itemize}

\section {Level or layer}

The vertical coordinate of a value in \dballe{} is described using a level
description or a layer description.

A level is defined univocally by a code table (\texttt{leveltype1}) and a
numerical value (\texttt{l1}).

A layer is defined univocally by its two bounding levels (\texttt{leveltype1},
\texttt{l1}, \texttt{leveltype2}, \texttt{l2}). 

See \ref{levels} for a description of the level types and associated level
values.


\section {Time range}

Another characteristic of a value in \dballe{} is the time period to which the
datum refers: it can be, for example, a value measured in a specific instant,
or a cumulated or averaged value over an interval of time.

The time range is defined by a table code (\texttt{pindicator}) and two
numerical values (\texttt{p1} and \texttt{p2}, see \ref{tranges}).

\section {Values}

The main work of \dballe{} is to store and access \emph{measured values}.

A measured value is a datum that can be expressed as a floating point (single
or double precision), integer, character or byte, depending on what value it
measures.

Every datum is univocally defined by a system of coordinates with 7 dimensions:

\begin{enumerate}
\item The variable \emph{type}, which describes the nature of the
      variable, such as what it measures and the units used for measuring.
      It is identified by a \emph{local B table descriptor} (see \ref{btable}).
\item The \emph{date and time} of validity of the datum, be it observed,
      forecast or estimated.
\item \emph{pseudoana} information about what generated the value (also
      defining its x and y coordinates).
\item The vertical coordinates in space, as a description of the \emph{level layer}.
\item The \emph{time range} of the measurement.
\item A \emph{network} or \emph{report} type, defining an homogeneous group of
      stations with the same kind of measures and management (for example:
      synop, metar, a specific kind of forecast...).
\end{enumerate}

You can find a list of all current B table descriptors in \ref{btable}.

The type of report implicitly defines a priority of the measured value over
other equivalent values.  This can be used to select a ``best value'' from a
specific set of coordinates, where for example, values measured by synoptic
stations are preferred over values measured by a satellite, which in turn is
preferred over a value computed by a forecast model.

Priorities associated to the report type can be customized when creating the
database (see \ref{fun-idba_scopa}).

Every measured value in \dballe{} can be assigned any number of extra
attributes, which can be used, for example, for quality control.

\dballe{} also supports storing values \emph{about} a station (such as station
height, or station name).  These are called \emph{pseudoana values} and are
handled just like values, with the exception that vertical coordinates,
datetime and time range have no meanings and are forced to default values.

Pseudoana values, just like normal values in \dballe{}, can have attributes and
any B code.  It is possible to have pseudoana values for a station on different
networks, although this is rarely needed and the {\tt ana} network is normally
used for pseudoana values.

See section \ref{sec-querying} for examples on how to work with values.

\section {Attributes}

Values in \dballe{} are also associated to zero or more \emph{attributes}.  An
attribute is a value that describes an aspect of a variable, like for example a
confidence interval.

Attributes in \dballe{} consist on a value and a local B table descriptor,
which describes the nature of the variable, such as what it represents and the
units in which it is represented.

Attributes are uniquely identified by the variable they refer to and the B
table descriptor of the attribute.  As a consequence, you can only have one
attribute per value with a specific B table descriptor.  This means that, for
example, a variable can have at most one confidence interval attribute.

See section \ref{sec-attrs} for examples on how to handle attributes.

\dballe{} defines some extra code tables to use as values for attributes: a
list is provided in section \ref{extract}.

\section {Input, output, actions}
\label{basics-inout}

Work with \dballe{} happens using \emph{action routines}.  An action routine
typically reads some input, performs an action and produces some output.
Example of action routines are {\tt idba\_voglioquesto} to query data from a
database and {\tt idba\_prendilo} to write data into the database.

The input and the output of action routines are collections of parameters which
have a name and a value.  A list of parameters can be found in
\ref{parmtable}.

You can set the input parameters using the {\tt idba\_set*} functions:
\label{fun-idba_set}

\begin{description}
\item[{\tt idba\_seti(handle, "param", intvalue)}]
  Set the input parameter to the integer value {\tt intvalue}

\item[{\tt idba\_setc(handle, "param", charvalue)}]
  Set the input parameter to the character value {\tt charvalue}

\item[{\tt idba\_setr(handle, "param", realvalue)}]
  Set the input parameter to the real value {\tt realvalue}

\item[{\tt idba\_setd(handle, "param", doublevalue)}]
  Set the input parameter to the real*8 value {\tt doublevalue}
\end{description}

You can read the output parameters using the {\tt idba\_enq*} functions:
\label{fun-idba_enq}

\begin{description}
\item[{\tt idba\_enqi(handle, "param", intvalue)}]
  Read the output parameter into the integer value {\tt intvalue}

\item[{\tt idba\_enqc(handle, "param", charvalue)}]
  Read the output parameter into the character value {\tt charvalue}

\item[{\tt idba\_enqr(handle, "param", realvalue)}]
  Read the output parameter into the real value {\tt realvalue}

\item[{\tt idba\_enqd(handle, "param", doublevalue)}]
  Read the output parameter into the real*8 value {\tt doublevalue}
\end{description}

Note that all {\tt idba\_set} functions set input parameters, while all {\tt
idb\_enq*} functions read output parameters.  You cannot read input parameters
or set output parameters: that is the job of action routines.

In other words, input and output parameters are different things.  In this
code:

\begin{verbatim}
c     A possible misunderstanding
      call idba_seti(handle, "height", 1)
      call idba_enqi(handle, "height", val)
\end{verbatim}

the value of {\tt val} after the {\tt idba\_enqi} will not probably be 1, and
it could be either a value indicating ``missing value'' (in case no {\tt
height} parameter is set in the output parameters) or a {\tt height} value
previously retrieved by an action routine.

To reset one input parameter you can use {\tt idba\_unset}:
\label{fun-idba_unset}

\begin{verbatim}
c     ...
c     We don't want to limit results by latitude this time
      call idba_unset(handle, "latmin")
      call idba_unset(handle, "latmax")
      call idba_voglioquesto(handle, count)
\end{verbatim}

Alternatively, you can reset an input parameter by setting it to one of the
special ``missing value'' values listed below.

To reset all input parameters you can use {\tt idba\_unsetall}:
\label{fun-idba_unsetall}

\begin{verbatim}
c     Restart the query from scratch
      call idba_unsetall(handle)
      call idba_setd(handle, "latmin", 10.D0)
c     ...
\end{verbatim}

To reset only Bxxyyy variables you can use {\tt idba\_unsetb}:
\label{fun-idba_unsetall}

\begin{verbatim}
c     Insert a new variable with the old station, level and so on
      call idba_unsetb(handle)
      call idba_setd(handle, "B12101", 21.5)
c     ...
\end{verbatim}

There is no way to reset output parameters: it is not needed since all action
routines will get rid of old output values before producing new ones.

In case one of the {\tt idba\_enq*} functions is called on a parameter which
does not exist, it will return a special value that indicates ``missing
value''.  This is a list of such special values:

\begin{tabular}{|l|l|}
\hline
{\em Data type} & {\em Missing value indicator}               \\
\hline
String  &  ""			\\
Int     & 0x7fffffff		\\
Real    & -1.1754944E-38	\\
Double  & -2.22507E-308		\\
\hline
\end{tabular}

\subsection {Input/output shortcuts}

\label{fun-shortcuts}

There are a few functions that are shortcuts to other input and output
functions:

\begin{description}
\item[{\tt idba\_enqdate(handle, year, month, day, hour, minute, second)}]
  is a shortcut to:
  \begin{verbatim}
  idba_enqi(handle, "year", year)
  idba_enqi(handle, "month", month)
  idba_enqi(handle, "day", day)
  idba_enqi(handle, "hour", hour)
  idba_enqi(handle, "min", minute)
  idba_enqi(handle, "sec", second)
  \end{verbatim}
\item[{\tt idba\_setdate(handle, year, month, day, hour, minute, second)}]
  is a shortcut to:
  \begin{verbatim}
  idba_seti(handle, "year", year)
  idba_seti(handle, "month", month)
  idba_seti(handle, "day", day)
  idba_seti(handle, "hour", hour)
  idba_seti(handle, "min", minute)
  idba_seti(handle, "sec", second)
  \end{verbatim}
\item[{\tt idba\_enqlevel(handle, type1, l1, type2, l2)}]
  is a shortcut to:
  \begin{verbatim}
  idba_enqi(handle, "leveltype1", type1)
  idba_enqi(handle, "l1", l1)
  idba_enqi(handle, "leveltype2", type2)
  idba_enqi(handle, "l2", l2)
  \end{verbatim}
\item[{\tt idba\_setlevel(handle, type1, l1, type2, l2)}]
  is a shortcut to:
  \begin{verbatim}
  idba_seti(handle, "leveltype1", type1)
  idba_seti(handle, "l1", l1)
  idba_seti(handle, "leveltype2", type2)
  idba_seti(handle, "l2", l2)
  \end{verbatim}
\item[{\tt idba\_enqtimerange(handle, type, p1, p2)}]
  is a shortcut to:
  \begin{verbatim}
  idba_enqi(handle, "pindicator", type)
  idba_enqi(handle, "p1", p1)
  idba_enqi(handle, "p2", p2)
  \end{verbatim}
\item[{\tt idba\_settimerange(handle, type, p1, p2)}]
  is a shortcut to:
  \begin{verbatim}
  idba_seti(handle, "pindicator", type)
  idba_seti(handle, "p1", p1)
  idba_seti(handle, "p2", p2)
  \end{verbatim}
\item[{\tt idba\_setcontextana(handle)}]
  sets the date, time, level and time range in the input record to some magic
  values, to signal that we are going to work with station attributes instead
  of normal values.
\end{description}

\section {API invariants}

\label{fun-error}

\begin{itemize}
\item All errors are reported as function return values
\item All results are reported as output parameters
\item All functions {\tt idba\_set*} set the input of action routines
\item All functions {\tt idba\_enq*} get the output of action routines
\end{itemize}

\section {Error management}

Errors can be handled by checking the return value of every function:

\begin{verbatim}
c     Example error handling
      ierr = idba_presentati(dbhandle, "dsn", "user", "password")
      if (ierr.ne.0) then
c       handle the error...
      end if
\end{verbatim}

Or they can be handled by installing a callback function that is automatically
called in case of error:

\begin{verbatim}
c     How to set a callback
c       * the first parameter is the error code that triggers the callback (0
c         means 'trigger on all errors')
c       * the second parameter is the routine to call when the error happens        
c         (remember to declare the function as 'external'
c       * the third parameter is a convenience arbitrary integer that will be
c         passed to the function
c       * the fourth parameter is used to return a handle that can be used to
c         remove the callback
      call idba_error_set_callback(0, error_handler, 42, cb_handle)
\end{verbatim}

The previous code will setup DB-ALLe to call {\tt error\_handler} after any error,
passing it the integer value 42.  The callback can be removed at any time by
calling {\tt idba\_error\_remove\_callback}:
 
\begin{verbatim}
c     How to remove a callback
      call idba_error_remove_callback(cb_handle)
\end{verbatim}

This is a useful error handling function:

\begin{verbatim}
c     The error handler needs to be declared 'external'
      external error_handler

c     Compute the length of a string
c     (this is an utility function that is used by the error handler
c      to print nicer error messages)
      integer function istrlen(string)
      character string*(*)
        istrlen = len(string)
        do while ((string(istrlen:istrlen).eq." " .or.
     $       string(istrlen:istrlen).eq."").and.
     $       istrlen.gt.0)
           istrlen = istrlen - 1
        enddo
        return
      end

c     Generic error handler: print all available information
c     about the error, then exit
      subroutine error_handler(val)
      integer val
      character buf*1000
        print *,ier," testcb in ",val
        call idba_error_message(buf)
        print *,buf(:istrlen(buf))
        call idba_error_context(buf)
        print *,buf(:istrlen(buf))
        call idba_error_details(buf)
        print *,buf(:istrlen(buf))
        call exit (1)
        return
      end
\end{verbatim}

This code introduces three new functions:

\begin{description}
\item[{\tt idba\_error\_message}]
  returns a string describing what type of error has happened.
\item[{\tt idba\_error\_context}]
  returns a string describing what \dballe{} was trying to do when the error
  happened.
\item[{\tt idba\_error\_details}]
  returns a detailed description of the error, when available.  If no detailed
  description is available, it returns an empty string.
\end{description}

A similar error handling behaviour can be obtained by using the predefined
convenience function {\tt idba\_default\_error\_handler}:

\label{fun-error-handler}

\begin{verbatim}
c     Declare the external function (not necessary if you include dballef.h)
      external idba_default_error_handler

c     Use it as the error handling callback
      call idba_error_set_callback(0, idba_default_error_handler, 1, cb_handle)
\end{verbatim}

An alternative error handler called {\tt
idba\_error\_handler\_tolerating\_overflows} is available: it exists on all
errors instead of value overflows, in what case it prints a warning to standard
error and allows the program to continue.  The overflow error can then be
catched, if needed, by inspecting the error code returned by the \dballe{}
function that causes the error.

This is how to use it:

\begin{verbatim}
c     Declare the external function (not necessary if you include dballef.h)
      external idba_error_handler_tolerating_overflows

c     Use it as the error handling callback
      call idba_error_set_callback(0, idba_error_handler_tolerating_overflows, 1, cb_handle)
\end{verbatim}


\chapter {A working session}
\label{ch-work}

\section{Including the \dballe{} interface file}

If you work using Fortran 90, \dballe{} comes with an interface file that you
can use to enable type checking on all the \dballe{} API.

To make use of the interface file, just include it at the beginning of your
program:

\begin{verbatim}
      include "dballe/dballef.h"
\end{verbatim}

The Fortran 90 interface also allows to replace all the functions {\tt
idba\_enqi}, {\tt idba\_enqr}, {\tt idba\_enqd} and {\tt idba\_enqc} with {\tt
idba\_enq} and to replace all the functions {\tt idba\_seti}, {\tt idba\_setr},
{\tt idba\_setd} and {\tt idba\_setc} with {\tt idba\_set}.

\section{Starting the work}

Before any action routine, you need to connect to the database.  Connecting to
the database will give you a \emph{handle} that you can use to open sessions.

This code will open a connection with \dballe{}, then it will start a session:

\label{fun-idba_presentati}
\label{fun-idba_preparati}

\begin{verbatim}
c     Connect to the database and get a handle to work with it
      call idba_presentati(dbhandle, "dsn", "username", "password")
      call idba_preparati(dbhandle, handle, "read", "read", "read")

c     ...do your work...

c     End of the work
      call idba_fatto(handle)
      call idba_arrivederci(dbhandle)
\end{verbatim}

You call {\tt idba\_presentati} to connect to the databse. The parameters are
the usual ODBC triplet of DSN, username and password. 
There are alternative ways of invoking {\tt idba\_presentati}: see appendix
\ref{dburls} for details.

You can call {\tt idba\_preparati} many times and get more handles.  This allows
to perform many operations on the database at the same time.

{\tt idba\_preparati} has three extra parameters that can be used to limit
write operations on the database, as a limited protection against programming
errors.

The first extra parameter controls access to pseudoana records and can have
these values:

\begin{description}
\item[{\tt "read"}] pseudoana records cannot be modified.
\item[{\tt "write"}] pseudoana records can be added and removed.
\end{description}

The second extra parameter control access to observed data and can have
these values:

\begin{description}
\item[{\tt "read"}] data cannot be modified in any way.
\item[{\tt "add"}] data can be added to the database, but existing data cannot
		   be modified.  Deletions are disabled.  This is used to
		   insert new data in the database while preserving the data
		   that was already present in it.
\item[{\tt "write"}] data can freely be added, overwritten and deleted.
\end{description}

The third extra parameter controls access to data attributes and can have
these values:

\begin{description}
\item[{\tt "read"}] attributes cannot be modified in any way.
\item[{\tt "write"}] attributes can freely be added, overwritten and deleted.
\end{description}

Note that some combinations are illegal, such as pseudoana=read and data=add
(when adding a new data, it's sometimes necessary to insert new pseudoana
records), or data=rewrite and attr=read (when deleting data, their attributes
are deleted as well).

\section{Starting the work on a message}

Instead of connecting to a database, you can use the \dballe{} API to read and
write message reports in BUFR, CREX format, and read, but not write, messages
in AOF format.

To do that, use {\tt idba\_messaggi} instead of both {\tt idba\_presentati} and
{\tt idba\_preparati}.  To write a message, your code will look like:

\begin{verbatim}
c     Connect to the database and get a handle to work with it
      call idba_messaggi(handle, "file.bufr", "r", "auto")

c     ...do your work...

c     End of the work
      call idba_fatto(handle)
\end{verbatim}

\label{fun-idba_messaggi}

{\tt idba\_messaggi} has three parameters:

\begin{enumerate}
\item the name of the file to open
\item the open mode ("r" for read, "w" for write or create)
\item the file format.  It can be "BUFR", "CREX", "AOF" or "AUTO".  "AUTO"
      tells \dballe{} to autodetect the file format, but it only works when
      reading files, not when writing new one.
\end{enumerate}

You can call {\tt idba\_messaggi} many times and read or write many files.  You
can even call {\tt idba\_messaggi} many time on the same file as long as you
open it read only.

Once you open a file, you can use the other \dballe{} functions on it.  There
are slight differences between working on a database and working on a file, and
they are explained later in the section ``Working with files'' (see \ref{db-file-differences}).


\section{Setting input and reading output}

Input to action routines is done using the functions {\tt idba\_set*}, and output
is read with the functions {\tt idba\_enq*} (see \ref{basics-inout}):

\begin{verbatim}
c     Set the extremes of an area and retrieve all the stations in it
      call idba_setd(handle, "latmin", 30.D0)
      call idba_setd(handle, "latmax", 50.D0)
      call idba_setd(handle, "lonmin", 10.D0)
      call idba_setd(handle, "lonmax", 20.D0)
      call idba_quantesono(handle, count)
   
c     Get the informations about a station
      do while (count.gt.0)
        call idba_elencamele(handle)
        call idba_enqc(handle, "name", cname)
        call idba_enqi(handle, "ana_id", id)
        call idba_enqd(handle, "lat", lat)
        call idba_enqd(handle, "lon", lon)
c       ....
        count = count - 1
      enddo
\end{verbatim}

Note that, when one uses {\tt idba\_setc}, {\tt idba\_seti}, {\tt idba\_enqc},
{\tt idba\_enqi} with parameters that have some decimal digits, \dballe{} will
work with values as if they did not have a decimal point.  That is, if latitude
$10.124323$ is read with {\tt idba\_enqi}, then the result will be $10124323$.

The following example shows exactly what happens:

\begin{verbatim}
c     Set the latitude to 30.0 degrees
      call idba_setr(handle, "lat", 30.0)
c     Set the latitude to 30.0 degrees
      call idba_setd(handle, "lat", 30.0D0)

c     Set the latitude to 0.00030 degrees
      call idba_seti(handle, "lat", 30)
c     Set the latitude to 30.0 degrees
      call idba_seti(handle, "lat", 3000000)

c     Set the latitude to 0.00030 degrees
      call idba_setc(handle, "lat", "30")
c     Set the latitude to 30.0 degrees
      call idba_setc(handle, "lat", "3000000")
\end{verbatim}

\subsection {Parameter names}

There are three different kinds of parameter names one can use: the \dballe{}
parameters, the WMO B variables and the variable aliases.

The \dballe{} parameters, fully described in \ref{parmtable}, are parameters
that have a special meaning to \dballe{}: for example they can be part of the
coordinate system, or space/time extremes to use to query the database.  They
are indicated simply with their name (for example, {\tt "lat"} or {\tt
"yearmin"}).

The WMO B variables, fully described in the WMO B table, represent all possible
sorts of observed data, and are indicated in the form ``B{\itshape xxyyy}'',
where {\itshape xxyyy} are the X and Y values from the WMO table B.  For more
details on working with observed data, see \ref{obsdata}.  For a list of all
the currently available B table descriptors, see \ref{btable}.

The variable aliases are short, easy to remember names which can be used
instead of frequently used WMO B variables.  For a list of all the currently
available aliases, see \ref{aliastable}.

\subsection{Queries and observed data}
\label{obsdata}

The {\tt idba\_set*} and {\tt idba\_enq*} functions can also be used to set and get
observation data.  To do so, use as parameter the string {\tt "Bxxyyy"}, where
{\tt xx} and {\tt yyy} are the X and Y values of the BUFR/CREX table B describing
the observed data.

For example:

\begin{verbatim}
c     Set the speed of the wind (very useful in summer)
      call idba_setr(handle, "B11002", 1.8)
c     Also set the temperature
      call idba_setr(handle, "B12001", 21.8)
      call idba_prendilo(handle)
\end{verbatim}


\subsection{Attributes}

\label{sec-attrs}

The {\tt idba\_set} and {\tt idba\_enq} groups of functions can also be used to
set and get attributes on data.  To do so, use as parameter the string {\tt
"*Bxxyyy"}, where {\tt xx} and {\tt yyy} are the X and Y values of the
BUFR/CREX table B describing the attribute.

For example:

\begin{verbatim}
c     Set the confidence of the wind speed value we inserted
c     in the last 'idba_prendilo'
      call idba_setr(handle, "*B33007", 75.0)
      call idba_setc(handle, "*var_related", "B11002")
      call idba_critica(handle)
\end{verbatim}

\section {Querying the database}

\ref{sec-querying}

Queries are made by giving one or more extremes of space, time, level or time
range.  You can refer to section \ref{parmtable} for a list of all available
query parameters (see the column ``On query input'').

\subsection {Querying the anagraphical data}

Example code to query all the stations in a given area:
\label{fun-idba_quantesono}
\label{fun-idba_elencamele}

\begin{verbatim}
      call idba_setd(handle, "latmin", 30.D0)
      call idba_setd(handle, "latmax", 50.D0)
      call idba_setd(handle, "lonmin", 10.D0)
      call idba_setd(handle, "lonmax", 20.D0)
      call idba_quantesono(handle, count)
      do while (count.gt.0)
        call idba_elencamele(handle)
        call idba_enqi(handle, "ana_id", id)
c       Pseudoana values can be read as well:
        call idba_enqc(handle, "name", cname)
        call idba_enqd(handle, "B07001", height)
c       ...query more data and work with it...
        count = count - 1
      enddo
\end{verbatim}

This code introduces two new functions:

\begin{description}
\item[{\tt idba\_quantesono}]
  performs the query and returns the number of stations it finds.

\item[{\tt idba\_elencamele}]
  gets a station out of the results of {\tt idba\_quantesono}.  If there are no
  more stations, the function fails.
\end{description}

After {\tt idba\_elencamele}, the output record will also contain all the
pseudoana values available for the station.  If {\tt rep\_cod} or {\tt
rep\_memo} are specified as query parameters, the pseudoana values of that
network will be used.  Else, {\tt idba\_elencamele} will use all available
pseudoana values, choosing the one in the network with the highest priority in
case the same pseudoana value is available on more than one network.


\subsection {Querying the values}

Example code to query all the values in a given area and time:
\label{fun-idba_voglioquesto}
\label{fun-idba_dammelo}

\begin{verbatim}
      call idba_seti(handle, "latmin", 30)
      call idba_seti(handle, "latmax", 50)
      call idba_seti(handle, "lonmin", 10)
      call idba_seti(handle, "lonmax", 20)
      call idba_seti(handle, "yearmin", 2004)
      call idba_seti(handle, "yearmax", 2004)
      call idba_voglioquesto(handle, count)
      do while (count.gt.0)
        call idba_dammelo(handle, param)
c       get the value of this variable
        call idba_enqc(handle, param, cvalue)
        call idba_enqd(handle, "lat", dlat)
        call idba_enqd(handle, "lon", dlon)
c       query more data and work with it
        count = count - 1
      enddo
\end{verbatim}
   
This code introduces two new functions:

\begin{description}
\item[{\tt idba\_voglioquesto}]
  performs the query and returns the number of values it finds.
\item[{\tt idba\_dammelo}]
  gets a value out of the result of {\tt idba\_voglioquesto}.  If there are no
  more stations, the function fails.
\end{description}

\subsection {Clearing the database}

You can initialise or reinitialise the database using {\tt idba\_scopa}:
\label{fun-idba_scopa}

\begin{verbatim}
c     Start the work with a clean database
      call idba_scopa(handle, "repinfo.csv")
\end{verbatim}

{\tt idba\_scopa} clears the database if it exists, then recreates all the
needed tables.  Finally, it populates the informations about the reports (such
as the available report types, their mnemonics and their priority) using the
data in the file given as argument.

The file is in CSV format, with 6 columns:
\begin{enumerate}
\item Report code (corresponding to parameter {\tt rep\_cod})
\item Mnemonic name (corresponding to parameter {\tt rep\_memo})
\item Report description
\item Report priority (corresponding to parameter {\tt priority})
\item Ignored
\item Ignored
\end{enumerate}

If {\tt ""} is given instead of the file name, {\tt idba\_scopa} will read the
data from {\tt /etc/repinfo.csv}.

This is an example of the contents of the file:

\begin{verbatim}
01,synop,report synottico,100,oss,0
02,metar,metar,80,oss,0
03,temp,radiosondaggio,100,oss,2
04,ana_lm,valori analizzati LM,-1,ana,255
05,ana,analisi,-10,pre,255
06,pre_cleps_box1.5maxel001,previsti cosmo leps box 1.5 gradi valore max elemento 1,-1,pre,255
07,pre_lmn_box1.5med,previzione Lokal Model nudging box 1.5 gradi valore medio,-1,pre,255
08,pre_lmp_spnp0,previsione Lkal Model prognostica interpolato punto piu' vicino,-1,pre,255
09,boe,dati omdametrici,100,oss,31
\end{verbatim}

{\tt idba\_scopa} will not work unless {\tt rewrite} has been enabled for the
data when opening the database.


\subsection {Inserting data}

Data is inserted using {\tt idba\_prendilo}:
\label{fun-idba_prendilo}
         
\begin{verbatim}
c     Insert a new data in the database
      call idba_setr(handle, "ana_id", 4)
      call idba_setr(handle, "rep_memo", "synop")
      call idba_setd(handle, "lat", 44.500D0)
      call idba_setd(handle, "lon", 11.328D0)
      call idba_setr(handle, "year", 2005)
      call idba_setr(handle, "month", 7)
      call idba_setr(handle, "day", 26)
      ...
      call idba_setr(handle, "B11002", 1.8)
      call idba_prendilo(handle)
\end{verbatim}

This code introduces a new function:

\begin{description}
\item[{\tt idba\_prendilo}]
  inserts a new value in the database.  All the information about the parameter
  to insert is taken from the input previously set by {\tt idba\_set*} functions.

  When data of the same kind and with the same characteristics already exists,
  the behaviour of {\tt idba\_prendilo} is defined by the parameter passed to
  {\tt idba\_preparati} when creating the handle.  See `Starting the work`\_ for
  more informations.
\end{description}

{\tt idba\_prendilo} will work in different ways according to the data opening
mode of the database:

\begin{description}
\item[{\tt read}]
  causes an error, because the data cannot be read.
\item[{\tt add}]
  new data can be inserted, but causes an error when trying to insert a value
  that already exists.
\item[{\tt rewrite}]
  new data can be inserted, and existing data is overwritten.
\end{description}

Also, behaviour changes according to the pseudoana opening mode:

\begin{description}
\item[{\tt "reuse"}] when inserting data, if an existing pseudoana record for
	       the data is found, it will be reused.
\item[{\tt "rewrite"}] when inserting data, if an existing pseudoana record for
	     the data is found, it will be completely overwritten with
	     the parameters in input.
\end{description}

Note that the database cannot be opened in pseudoana {\tt read} mode when data
is {\tt add} or {\tt rewrite}.
  
\section{Deleting data}

Data is deleted using {\tt idba\_dimenticami}:
\label{fun-idba_dimenticami}

\begin{verbatim}
c     Delete all data from the station with id 4 in year 2002
      call idba_seti(handle, "ana_id", 4)
      call idba_seti(handle, "year", 2002)
      call idba_dimenticami(handle)
\end{verbatim}

This code introduces a new function:

\begin{description}
\item[{\tt idba\_dimenticami}]
  deletes all the data found in the extremes specified in input.
\end{description}

{\tt idba\_dimenticami} will not work unless {\tt rewrite} has been enabled for
the data when opening the database.

\section {Attributes}

\subsection{Reading attributes}

Attributes are read using {\tt idba\_ancora}:
\label{fun-idba_voglioancora}
\label{fun-idba_ancora}

\begin{verbatim}
c     ...setup a query...
      idba_voglioquesto(handle, count)
      do while (count.gt.0)
        call idba_dammelo(handle, param)

c       Read QC informations about the last value read
        call idba_voglioancora(handle, qc_count)
        do while (qc_count.gt.0)
            call idba_ancora(handle, param) 
            call idba_enqc(handle, param, value)
c           ...process the value...
            qc_count = qc_count - 1
        enddo

        count = count - 1
      enddo
\end{verbatim}

This code introduces two new functions:

\begin{description}
\item[{\tt idba\_voglioancora}]
  Performs a query to retrieve attributes for the last variable read by
  {\tt idba\_dammelo}.  It returns the number of attributes available.
\item[{\tt idba\_ancora}]
  Retrieves one by one the values queried by {\tt idba\_voglioancora} if
  there are no more items available, the function will fail.

  The parameter {\tt param} will be set to the name (in the form {\tt *Bxxyyy}) of
  the attribute just read.
\end{description}

It is possible to read attributes at a later time giving a context ID and a B
table value:

\begin{verbatim}
c     Read the context ID after a prendilo or a dammelo
      idba_enqi(handle, "context_id", id)

c     ...a while later...

c     Query the attributes of the variable with the given
c     context ID and B table value
      idba_seti(handle, "*context_id", id)
      idba_seti(handle, "*var_related", "B12001")

c     These are ways one could choose specific attributes:
c     one attribute: idba_setc(handle, "*var", "B33007")
c     some attributes: idba_setc(handle, "*varlist", "B33007,B33036")
c     by default, all attributes are returned

c     Read QC informations about the last value read
      call idba_voglioancora(handle, qc_count)
      do while (qc_count.gt.0)
          call idba_ancora(handle, param) 
          call idba_enqc(handle, param, value)
c         ...process the value...
          qc_count = qc_count - 1
      enddo
\end{verbatim}

\subsection{Writing attributes}

\label{fun-idba_critica}

Attributes are written using {\tt idba\_critica}, which can be used after an
{\tt idba\_dammelo}, after an {\tt idba\_prendilo} or at any time using a stored data
id.  These three case differ on how to communicate to {\tt idba\_critica} what is
the data about which to write attributes.

When used after {\tt idba\_dammelo}, {\tt idba\_critica} can refer directly to the
last data retrieved:

\begin{verbatim}
c     ...setup a query...
      call idba_voglioquesto(handle, count)
      do while (count.gt.0)
        call idba_dammelo(handle, param)
c       ...process data...

c       Set the attributes
        call idba_seti(handle, "*B33007", 75)
        call idba_seti(handle, "*B33006", 42)
        call idba_critica(handle)

        count = count - 1
      enddo
\end{verbatim}

After an {\tt idba\_prendilo} instead, since {\tt idba\_prendilo} can write more than
one data at a time, we need to tell {\tt idba\_critica} which of them we are
referring to:

\begin{verbatim}
c     Insert wind speed and temperature
      call idba_setr(handle, "B11002", 1.8)
      call idba_setr(handle, "B12001", 22)
      call idba_prendilo(handle)

c     Set the attributes
      call idba_seti(handle, "*B33007", 75)

c     Use "*var_related" to indicate which of the two variables we are annotating
      call idba_setc(handle, "*var_related", "B11002")

      call idba_critica(handle)
\end{verbatim}


{\tt idba\_critica} can also be called at any time using a previously stored data it:

\begin{verbatim}
c     ...perform a query with idba\_voglioquesto...
      do while (count.gt.0)
        call idba_dammelo(handle, param)
c       ...process data...

c       This variable is interesting: save the context ID
c       to refer to it later
        call idba_enqi(handle, "context_id", saved_id)
        
        count = count - 1
      enddo

c     ...some time later...

c     Insert attributes about that interesting variable
      call idba_seti(handle, "*B33007", 75)
      call idba_seti(handle, "*B33006", 42)
      
c     Select the variable using its context id
c     and variable code
      call idba_seti(handle, "*context_id", saved_id)
      call idba_seti(handle, "*var_related", "B11001")
      call idba_critica(handle)
\end{verbatim}

This code introduces a new function:

\begin{description}
\item[{\tt idba\_critica}]
  Set one or more attributes about a variable.
  
  The variable can be identified directly by using {\tt idba\_seti(handle,
  "*context\_id", id)} and {\tt idba\_seti(handle, "*var\_related", name)}.
  These parameters are automatically set by the {\tt idba\_dammelo} and {\tt
  idba\_prendilo} action routines.

  The attributes and values are set as input to {\tt idba\_critica} using the
  {\tt idba\_set*} functions with an asterisk in front of the variable name.
\end{description}


{\tt idba\_critica} will work in different ways according to the attributes
opening mode of the database:

\begin{description}
\item[{\tt "read"}] attributes cannot be modified in any way.
\item[{\tt "rewrite"}] attributes can be added, and existing attributes can be
                   overwritten.
\end{description}


\subsection{Deleting attributes}

Attributes are deleted using {\tt idba\_scusa}:

\label{fun-idba_scusa}

\begin{verbatim}
c     Delete the confidence interval from the wind speed

c     The referring variable is identified in the same way as with
c     idba_critica:
      call idba_seti(handle, "*context_id", saved_id)
      call idba_seti(handle, "*var_related", "B11002")

c     The attributes to delete are selected by setting "*varlist":
      call idba_setc(handle, "*varlist", "*B33007")
      call idba_scusa(handle)
\end{verbatim}

This code introduces a new function:

\begin{description}
\item[{\tt idba\_scusa}]
  Delete attributes from a variable identified in the same way as with {\tt
  idba\_critica}.  By default it deletes all attributes; specific attributes to
  delete can be selected by setting their names, separated by commas, in the
  "*varlist" variable.
\end{description}

{\tt idba\_scusa} will not work unless the database has been opened in
attribute {\tt rewrite} mode.


\section{Ending the work}

When you are finished working with a handle, you can release it with {\tt idba\_fatto}

\label{fun-idba_fatto}

\begin{verbatim}
c     We are finished with this handle
      call idba_fatto(handle)
\end{verbatim}

When you are finished working with DB-ALLe, you can ask it to close all
connections and release all resources:

\label{fun-idba_arrivederci}

\begin{verbatim}
c     We do not need to work with dballe anymore
      call idba_arrivederci(dbh)
\end{verbatim}

\chapter{Advanced topics}

\section{Shortcuts to stations and data}

\dballe{} offers two shortcuts to represent pseudoana entries and data in the
database: the {\tt ana\_id} and the {\tt data\_id} keys, that are set in the
output of every {\tt idba\_dammelo}.

{\tt ana\_id} represents a pseudoana entry.  Every time one needs to specify a
set of latitude, longitude, fixed/mobile, one could use the corresponding {\tt
ana\_id} value, if known, and get a faster search.

{\tt data\_id} represents a data entry.  Every time one needs to identify some
data setting latitude, longitude, level layer, time range and so on, one can
just provide the value of {\tt data\_id}, and also get a faster search.

\section{Helpers for pretty printing}

\label{fun-pprint}

There are a number of functions in \dballe{}, the {\tt idba\_spiega\*} group of
functions, that are not needed for normal processing but can be useful to
improve the presentation of data to users.

All these function take a number of parameters and a string, and they store a
proper description of the values into the string.

The functions are:

\begin{description}
\item[{\tt idba\_spiegal(handle,ltype1,l1,ltype2,l2,string)}]
  Describes a level.  For example, {\tt idba\_spiegal(handle,106,10,106,20,string)}
  will store in {\tt string} something like: ``\emph{Layer between 10hm and
  20hm above ground}``.
\item[{\tt idba\_spiegat(handle,ptype,p1,p2,string)}]
  Describes a time range.  For example, {\tt idba\_spiegat(handle,3,0,600,string)}
  will store in {\tt string} something like: ``\emph{Average between reference
  time+0s to reference time+600s}``.
\item[{\tt idba\_spiegab(handle,varcode,value,string)}]
  Describe a value.  For example, {\tt idba\_spiegab(handle,"B12001","280",string)}
  will store in {\tt string} something like: ``\emph{280 (K)
  TEMPERATURE/DRY-BULB TEMPERATURE}``.
\end{description}

\section{Query modifiers}

\dballe{} allows to set special query behaviours using the {\tt "query"}
parameter.  The available options are:

\begin{description}
\item [best]
  When measures from different kinds of reports exist in the same physical
  space, do not return them all, but only return the one of the record type
  with the highest priority.
\item [bigana]
  Use special query optimizations that make things faster when there are a lot
  of stations in the database, and slower otherwise.  If you are having slow
  queries, try setting this option and see if it helps.
\item [nosort]
  Return the results in a nondefined order.  It can make things faster when
  writing algorithms that do not depend on the ordering of data from \dballe{}.
\item [stream]
  Normally the functions {\tt idba\_quantesono} or {\tt idba\_voglioquesto}
  will read all the results from the server, count them and save them locally.

  When using this option, those functions will return right after performing
  the query, and the results will be read later using {\tt idba\_elencamele} or
  {\tt idba\_dammelo}.  As a side effect, {\tt idba\_quantesono} and
  {\tt idba\_voglioquesto} cannot know in advance the result count, and will
  return some undefined value in it.

  When using this option, the only way to find out when to stop reading is to
  know that {\tt idba\_elencamele} and {\tt idba\_dammelo} will set all the
  output parameters to undefined when there is no more data to read.  One could
  thus use a loop like this:
  \begin{verbatim}
      call idba_setc (handle, "query", "stream")
c     Make the query
      call idba_voglioquesto (handle, N)
c     Iterate the results.  Ignore N because it is
c     meaningless when using query=stream
      do
        call idba_dammelo (handle, varname)
c       If ana_id is missing value, then we are done
        idba_enqi(handle, "ana_id", value)
        if (value .eq. 2147483647) exit

c       ...process the data...
      enddo
  \end{verbatim}

  This option can be a significant improvement in speed and memory when the
  result count is not needed in advance.  The speed improvement comes because
  the client can start doing computations on the results while the server is
  still generating the results, taking advantage of parallelism, especially if
  the server and the application are on two different computers.

  Without using this option, the client cannot start to use the results until
  the server has finished computing and trasmitting them.
\end{description}

\section{Working with files}
\label{db-file-differences}

This is a list of the differences between working with files and working with
databases:

\begin{itemize}
\item You do not need to call {\tt idba\_presentati} and {\tt
      idba\_arrivederci}: the work session starts at {\tt idba\_messaggi} and ends at
      {\tt idba\_fatto}
\item When reading, performing {\tt idba\_quantesono} or {\tt
      idba\_voglioquesto} a second time advances to the next message in the file.
\item Query parameters set before an {\tt idba\_voglioquesto} have no effect:
      filtering data is not implemented for files. Since it may be implemented
      in the future, it is suggested to avoid setting query parameters before
      an {\tt idba\_voglioquesto} to avoid unexpected changes of behaviour with
      future versions of \dballe{}.
\item When reading, you will see that there are no more messages because {\tt
      idba\_quantesono} or {\tt idba\_voglioquesto} will return 0.
\item When writing, you can use the {\tt query} input parameter to {\tt
      idba\_prendilo} to control when a new message is started.  If you set it
      to {\tt subset}, then the data will be inserted in a new BUFR or CREX
      subset.  If you set it to {\tt message}, you will start a new message.

      After ``message'' you can specify a template for the message, using one
      of the names listed by {\tt dbadb export -t list}, for example: ``{\tt message
      generic}''.  If you do not specify a template name, an appropriate template
      will automatically be chosen for you.
\item You cannot use {\tt rep\_memo}: only {\tt rep\_cod} works.  Setting {\tt
      rep\_cod} you can influence the output template of messages: if you set it to a
      synop report code, you will create a synop message.
\end{itemize}


\chapter{Code examples}
\label{ch-examples}

% TODO: put some more example code snippets from real-world

\section{Insert station data, then insert data}

\begin{verbatim}
      call idba_preparati(dbhandle, handle, "write", "add", "write")
      
c     Insert data about a station
      call idba_setr (handle, "lat", 11.345)
      call idba_setr (handle, "lon", 44.678)
      call idba_setr (handle, "height", 23)
      call idba_prendilo (handle)

c     Read the station ID for the station we just inserted
c     Use *ana_id instead of ana_id after an idba_prendilo
      call idba_enqi (handle, "*ana_id", anaid)

c     Reset the input data
      call idba_unsetall (handle)

c     Add data to the station we just inserted
      call idba_seti (handle, "ana_id", anaid)
      call idba_setlevel (handle, 100, 1, 0, 0)
      call idba_settimerange (handle, 0, 0, 0)
      call idba_setdate (handle, 2006, 06, 20, 19, 30, 0)
      call idba_seti (handle, "t", 21)
      call idba_setc (handle, "B12345", "ciao")
      call idba_prendilo (handle)
\end{verbatim}


\section{Query data, then query station data}

\begin{verbatim}
      call idba_preparati(dbhandle, handle, "read", "read", "read")
      call idba_preparati(dbhandle, handleana, "read", "read", "read")
      
c     Prepare a query
      call idba_setd (handle, "latmin", 10)
      ...
      call idba_setd (handle, "lonmax", 60)

c     Make the query
      call idba_voglioquesto (handle, N)

c     Iterate the results
      do i=1,N
        call idba_dammelo (handle, varname)

c       Read data about the variable we just had
        call idba_enqlevel (handle, ltype, l1, l2)

c       Read pseudoana data about the variable we just had
c       Setup a query for the station with 'quantesono'
        call idba_enqi (handle, "ana_id", anaid)
        call idba_seti (handleana, "ana_id", anaid)

c       Query.  Nstaz should always be 1 because we query a specific station
        call idba_quantesono (handleana, Nstaz)

c       Fetch the data
        call idba_elencamele (handleana)

c       Read the data about the station
c       All the data inserted with setcontextana is available here
        call idba_enqi (handleana, "height", height)
      enddo
\end{verbatim}


\chapter{FAQ and Troubleshooting}
\label{ch-trouble}

\begin{description}
\item [ {\tt call idba\_setc (handle, "query", "stream")} does not make any difference ]
  Because of a quirk of the MySQL ODBC driver, you may need to add a special
  configuration option to the MySQL driver.
  
  These are the instructions that you, or the person who set up ODBC in your
  computer, can follow:
  \begin{quote}
  You need to add 1048576 to the value of the Options
  field of the configuration of the ODBC DSN.

  This can be done by adding the line {\tt Option = 1048576} to the file {\tt
  odbc.ini}, or editing the Options field using the graphical ODBC
  configuration tool.
  \end{quote}

\item [ How do I access the extra station data? ]
  There are two ways:
  \begin{enumerate}
  \item If you know in advances what variables you want to read, you can find
        them among the results of {\tt idba\_elencamele}:
	\begin{verbatim}
c     Query station data
      call idba_quantesono(handle, count)
   
c     Get the informations about a station
      do i=1,count
        call idba_elencamele(handle)
        call idba_enqc(handle, "name", cname)
        call idba_enqi(handle, "B02001", type)
c       ....
      enddo
	\end{verbatim}
  \item If you want to see all the extra station data available, you can make
	an explicit query for the extra station data using {\tt
	idba\_voglioquesto} and {\tt idba\_dammelo}
	\begin{verbatim}
      call idba_seti("ana_id", id)
      call idba_voglioquesto(handle, count)
      do i=1,count
        call idba_dammelo(handle, param)
c       get the value of this variable
        call idba_enqc(handle, param, cvalue)
        print*,param,": ",cvalue
      enddo
	\end{verbatim}
  \end{enumerate}
\end{description}

\appendix

\chapter{Input and output parameters}

\section{For data-related action routines}

\label{parmtable}
\input{../dballe/core/record_keyword.tex}

\section{For attribute-related action routines}

{\begin{scriptsize}
\begin{longtable}{|@{\hspace{0.5mm}}l@{\hspace{0.5mm}}|@{\hspace{0.5mm}}l@{\hspace{0.5mm}}|@{\hspace{0.5mm}}l@{\hspace{0.5mm}}|@{\hspace{0.5mm}}p{2.0cm}@{\hspace{0.5mm}}|@{\hspace{0.5mm}}p{1.4cm}@{\hspace{0.5mm}}|@{\hspace{0.5mm}}p{1.4cm}@{\hspace{0.5mm}}|@{\hspace{0.5mm}}p{1.4cm}@{\hspace{0.5mm}}|@{\hspace{0.5mm}}p{3.5cm}@{\hspace{0.5mm}}|}
\hline
{\em Name} & {\em Unit} & {\em Format} & {\em Description} & {\em On insert input} & {\em On query input} & {\em On output} & {\em Comment} \\
\hline
\endhead
\hline
\endfoot
{\tt *Bxxyyy} & depends & depends & Value of the attribute & required & ignored & present & \\
{\tt *var} & Character & 7 chars & Attribute queried & ignored & optional & present, indicates the name of the last attribute returned &  \\
{\tt *varlist} & Character & 255 chars & List of attributes to query & ignored & optional & absent & Comma-separated list of attribute B codes wanted on output \\
{\tt *var\_related} & Character & 6 chars & Variable related to the attribute to query & required & required & absent & It is automatically set by {\tt idba\_dammelo} and {\tt idba\_prendilo} (when {\tt idba\_prendilo} inserts a single variable) \\
{\tt *context\_id} & Numeric & 10 digits & Context ID of the variable related to the attribute to query & required & required & absent & It is automatically set by {\tt idba\_dammelo} and {\tt idba\_prendilo} \\
\hline
\end{longtable}
\end{scriptsize}
}


\chapter{Values for level/layer and time range}

\section{Level/layer}
\label{levels}

\input{../dballe/msg/ltypes.tex}

\section{Time range}
\label{tranges}

\input{../dballe/msg/tranges.tex}

\chapter{Contents of the local B table}

\section{B table contents}

\label{btable}
\input{../tables/dballe.tex}

\section{Extra code tables}
\label{extract}

This section lists extra code tables defined by \dballe{} that define useful
values to be used as attributes.

\subsection{Code table 33196: \emph{Data has been invalidated}}

This attribute is useful to mark when a value has been invalidated as a
consequence of quality checks.

\begin{tabular}{|l|l|}
\hline
{\em Value} & {\em Description}               \\
\hline
          0 & data has been checked and not invalidated  \\
          1 & data has been not invalidated              \\
    missing & data has not beek checked                  \\
\hline
\end{tabular}

\subsection{Code table 33197 \emph{Manual replacement in substitution}}

This attribute is useful to track when a value has been manually substitute,
and it allows to identify both the original value and the new value that
substituted it.

\begin{tabular}{|l|l|}
\hline
{\em Value} & {\em Description}               \\
\hline
          0 & no substitution happened                                 \\
          1 & substitution happened, and this is the original value    \\
          2 & substitution happened, and this is the substituted value \\
    missing & no substitution information                              \\
\hline
\end{tabular}


\chapter{Variable aliases}

\label{aliastable}
\input{../dballe/core/aliases.tex}

\chapter{Database connection methods}

\label{dburls}

Instead of the usual DSN, user and password triplet it is possible to connect
to the database using an URL-like syntax.

\section{Connecting via ODBC}

Specifying DSN, user and password:

\begin{description}
\item[in Fortran]
  {\tt call idba\_presentati(dbhandle, "dsn", "username", "password")}
\item[with dbadb]
  {\tt dbadb \-\-dsn=dsn \-\-user=username \-\-pass=password}
\item[with provami]
  {\tt provami \-\-dsn=dsn \-\-user=username \-\-pass=password}
\end{description}

Via URL:

\begin{description}
\item[in Fortran]
  {\tt call idba\_presentati(dbhandle, "odbc://username:password@dsn", DBA\_MVC, DBA\_MVC)}
\item[with dbadb]
  {\tt dbadb \-\-dsn="odbc://username:password@dsn" \dots}
\item[with provami]
  {\tt provami \-\-dsn="odbc://username:password@dsn"}
\end{description}

Via an environment variable:

\begin{verbatim}
# Export the environment variable
export DBA_DB="odbc://username:password@dsn"
\end{verbatim}

\begin{description}
\item[in Fortran]
  {\tt call idba\_presentati(dbhandle, DBA\_MVC, DBA\_MVC, DBA\_MVC)}
\item[with dbadb]
  {\tt dbadb \dots}
\item[with provami]
  {\tt provami}
\end{description}

\section{Using a SQLite file directly}

Using SQLite makes \dballe{} very slow, but it is very useful when working with
small datasets since it does not require any ODBC set up. For example, it can
be used to run software to process small BUFR files:

\begin{verbatim}
export DBA_DB="sqlite:temp.sqlite"
dbadb wipe
dbadb import data.bufr
# ...run something here that processes the data...
dbadb export > processed-data.bufr
rm temp.sqlite
\end{verbatim}

Via URL:

\begin{description}
\item[in Fortran]
  {\tt call idba\_presentati(dbhandle, "sqlite:file.sqlite", DBA\_MVC, DBA\_MVC)}
\item[with dbadb]
  {\tt dbadb \-\-dsn="sqlite:file.sqlite" \dots}
\item[with provami]
  {\tt provami \-\-dsn="sqlite:file.sqlite"}
\end{description}

Via an environment variable:

\begin{verbatim}
# Export the environment variable
export DBA_DB="sqlite:file.sqlite"
\end{verbatim}

\begin{description}
\item[in Fortran]
  {\tt call idba\_presentati(dbhandle, DBA\_MVC, DBA\_MVC, DBA\_MVC)}
\item[with dbadb]
  {\tt dbadb \dots}
\item[with provami]
  {\tt provami}
\end{description}


\chapter{Summary of routines}

This appendix contains some reference tables for the functions in the Fortran
API.

\section{Input/Output routines}

These routines are used to set the input and read the output of action routines.

\begin{tabular}{|l|l|l|}
\hline
{\em Name}                      & {\em Description}                & {\em See} \\
\hline
{\tt \small idba\_seti(h, param, val)} & Set an integer in input          & \ref{fun-idba_set} \\
{\tt \small idba\_setr(h, param, val)} & Set a real in input              & \ref{fun-idba_set} \\
{\tt \small idba\_setd(h, param, val)} & Set a double in input            & \ref{fun-idba_set} \\
{\tt \small idba\_setc(h, param, val)} & Set a character in input         & \ref{fun-idba_set} \\
{\tt \small idba\_unset(h, param)}     & Unset a value from the input     & \ref{fun-idba_unset} \\
{\tt \small idba\_unsetall(h)}         & Unset all values from the input  & \ref{fun-idba_unsetall} \\
{\tt \small idba\_unsetb(h)}           & Unset B* values from the input   & \ref{fun-idba_unsetb} \\
{\tt \small idba\_enqi(h, param, val)} & Read an integer from the output  & \ref{fun-idba_enq} \\
{\tt \small idba\_enqr(h, param, val)} & Read a real from the output      & \ref{fun-idba_enq} \\
{\tt \small idba\_enqd(h, param, val)} & Read a double from the output    & \ref{fun-idba_enq} \\
{\tt \small idba\_enqc(h, param, val)} & Read a character from the output & \ref{fun-idba_enq} \\
\hline
\end{tabular}

The following routines are shortcuts for combinations of the above ones.

\begin{tabular}{|l|p{6cm}|l|}
\hline
{\em Name}					& {\em Description}	& {\em See} \\
\hline
{\tt \small idba\_setcontextana(h)}		& Set query parameters to the anagraphical context & \ref{fun-shortcuts} \\
{\tt \small idba\_enqlevel(h,type1,l1,type2,l2)}	& Read level data	& \ref{fun-shortcuts} \\
{\tt \small idba\_setlevel(h,type1,l1,type2,l2)}	& Set level data	& \ref{fun-shortcuts} \\
{\tt \small idba\_enqtimerange(h,type,p1,p2)}	& Read time range data	& \ref{fun-shortcuts} \\
{\tt \small idba\_settimerange(h,type,p1,p2)}	& Set time range data	& \ref{fun-shortcuts} \\
{\tt \small idba\_enqdate(h,y,m,d,h,m,s)}	& Read date information & \ref{fun-shortcuts} \\
{\tt \small idba\_setdate(h,y,m,d,h,m,s)}	& Set date information	& \ref{fun-shortcuts} \\
{\tt \small idba\_setdatemin(h,y,m,d,h,m,s)}	& Set minimum date for a query	   & \ref{fun-shortcuts} \\
{\tt \small idba\_setdatemax(h,y,m,d,h,m,s)}	& Set maximum date for a query	   & \ref{fun-shortcuts} \\
\hline
\end{tabular}


\section{Session routines}

These routines are used to begin and end working sessions with \dballe{}.

\begin{tabular}{|l|l|l|}
\hline
{\em Name} & {\em Description} & {\em See} \\
\hline
{\tt \small idba\_presentati(dbh,dsn,user,pwd)} & Connect to the database & \ref{fun-idba_presentati} \\
{\tt \small idba\_preparati(dbh,h,mana,mdata,mattr)} & Open a new session & \ref{fun-idba_preparati} \\
{\tt \small idba\_messaggi(h,filename,mode,type)}  & Work with a message file & \ref{fun-idba_messaggi} \\
{\tt \small idba\_fatto(h)}                        & Close a session              & \ref{fun-idba_fatto} \\
{\tt \small idba\_arrivederci(dbh)}                & Disconnect from the database & \ref{fun-idba_arrivederci} \\
\hline
\end{tabular}


\section{Action routines}

\begin{tabular}{|l|l|l|}
\hline
{\em Name} & {\em Description} & {\em See} \\
\hline
{\tt \small idba\_scopa(h, filename)}     & Reinitialise the database       & \ref{fun-idba_scopa} \\
{\tt \small idba\_quantesono(h, count)}   & Query the stations archive      & \ref{fun-idba_quantesono} \\
{\tt \small idba\_elencamele(h)}          & Fetch data about a station      & \ref{fun-idba_elencamele} \\
{\tt \small idba\_voglioquesto(h, count)} & Query the data archive          & \ref{fun-idba_voglioquesto} \\
{\tt \small idba\_dammelo(h, param)}      & Fetch one observed data         & \ref{fun-idba_dammelo} \\
{\tt \small idba\_prendilo(h)}            & Insert values in the database   & \ref{fun-idba_prendilo} \\
{\tt \small idba\_dimenticami(h)}         & Remove values from the database & \ref{fun-idba_dimenticami} \\
{\tt \small idba\_voglioancora(h, count)} & Query QC data about a value     & \ref{fun-idba_voglioancora} \\
{\tt \small idba\_ancora(h, param)}       & Fetch QC data                   & \ref{fun-idba_ancora} \\
{\tt \small idba\_critica(h)}             & Insert QC data about a value    & \ref{fun-idba_critica} \\
{\tt \small idba\_scusa(h)}               & Remove QC data                  & \ref{fun-idba_scusa} \\
\hline
\end{tabular}

\section{Pretty printing routines}

\begin{tabular}{|l|l|l|}
\hline
{\em Name} & {\em Description} & {\em See} \\
\hline
{\tt \small idba\_spiegal(handle,ltype1,l1,ltype2,l2,string)}   & Describe a level layer & \ref{fun-pprint} \\
{\tt \small idba\_spiegat(handle,ptype,p1,p2,string)}   & Describe a time range  & \ref{fun-pprint} \\
{\tt \small idba\_spiegab(handle,varcode,value,string)} & Describe a value       & \ref{fun-pprint} \\
\hline
\end{tabular}

\section{Error management routines}

\begin{tabular}{|l|p{6cm}|l|}
\hline
{\em Name} & {\em Description} & {\em See} \\
\hline
{\tt \small idba\_error\_code()}              &
	Return the error code of the last function		& \ref{fun-error} \\
{\tt \small idba\_error\_message(msg)}        &
	Get the error message of the last function		& \ref{fun-error} \\
{\tt \small idba\_error\_context(msg)}        &
	Get the context description for the error of the last function & \ref{fun-error} \\
{\tt \small idba\_error\_details(msg)}        & 
	Get details about the error of the last function	& \ref{fun-error} \\
{\tt \small idba\_error\_set\_callback(code,fun,data,h)} &
	Set a callback for handling errors			& \ref{fun-error} \\
{\tt \small idba\_error\_remove\_callback(h)} &
	Remove a previously set callback			& \ref{fun-error} \\
{\tt \small idba\_default\_error\_handler}     &
	Predefined convenience error handler			& \ref{fun-error-handler} \\
{\tt \small idba\_error\_handler\_tolerating\_overflows}     &
	Predefined convenience error handler that does not exist on overflow errors & \ref{fun-error-handler} \\
\hline
\end{tabular}


\bibliography{local}

\end{document}


