#!/usr/bin/python3

import os
os.environ["DBALLE_BUILDING_DOCS"] = "true"  # noqa
import sys
import re
import inspect
import dballe
import dballe.volnd

re_docparsep = re.compile(r"\n(?:\s*\n)+")
re_signature = re.compile(r"\S+\(.*\)")
re_linebreak = re.compile(r"\s*\n\s*")


def split_doc_summary(doc):
    res = re_docparsep.split(doc, maxsplit=1)
    if len(res) == 1:
        dstrip = doc.strip()
        if "\n" in dstrip:
            return None, doc
        else:
            return doc, None
    else:
        summary = re_linebreak.sub(" ", res[0])
        return summary, res[1]


class Generator:
    def __init__(self):
        self.whitespace = True

    def spacer(self):
        if self.whitespace:
            return
        print()
        self.whitespace = True

    def print(self, *args, **kw):
        self.whitespace = False
        print(*args, **kw)

    def print_indented(self, spaces, *args):
        "Print a string, indented by the given number of spaces"
        self.whitespace = False
        for s in args:
            for line in s.split("\n"):
                for i in range(1, spaces):
                    sys.stdout.write(" ")
                sys.stdout.write(line.replace("wreport.", "dballe."))
                sys.stdout.write("\n")

    def text(self, text: str):
        self.print(text.lstrip())

    def para(self, text: str):
        if not self.whitespace:
            print()
        print(text.lstrip())
        print()
        self.whitespace = True

    def title(self, line, char='-', over=False):
        self.spacer()
        if over:
            print(char * len(line))
        print(line)
        print(char * len(line))
        print()

    def document_class(self, cls):
        name = cls.__name__
        self.title("dballe.{}".format(name))
        self.print(inspect.getdoc(cls).replace("wreport.", "dballe."))
        if self.has_members(cls):
            self.title("Members", char="`")
            self.document_members(cls)
        self.spacer()

    def document(self, obj):
        if obj.__doc__ is None:
            return

        if inspect.ismodule(obj):
            self.print_indented(0, inspect.getdoc(obj))
            self.spacer()
        elif inspect.isroutine(obj) and inspect.isfunction(obj):
            # A Python function
            self.print_indented(2, '``'+obj.__name__ + inspect.formatargspec(*inspect.getargspec(obj))+"``")
            self.print_indented(4, inspect.getdoc(obj))
        else:
            self.print_indented(2, obj.__name__)
            self.print_indented(4, inspect.getdoc(obj))

    def document_getsetter(self, cls, name, obj):
        doc = inspect.getdoc(obj)

        summary, rest = split_doc_summary(doc)
        if summary:
            if rest:
                self.print_indented(2, "{}.{}: {}".format(cls.__name__, name, summary))
                self.print_indented(4, rest)
            else:
                self.print_indented(2, "{}.{}".format(cls.__name__, name))
                self.print_indented(4, summary)
        else:
            self.print_indented(2, "{}.{}".format(cls.__name__, name))
            self.print_indented(4, doc)

    def document_cfunction(self, cls, name, obj):
        # Split signature and summary
        doc = inspect.getdoc(obj)

        signature, rest = split_doc_summary(doc)
        if signature and re_signature.search(signature):
            if signature.startswith(cls.__name__ + "."):
                signature = signature[len(cls.__name__) + 1:]
            self.print_indented(2, "{}.{}".format(cls.__name__, signature))
            if rest:
                self.print_indented(4, rest)
        else:
            self.print_indented(2, "{}.{}(â€¦)".format(cls.__name__, name))
            self.print_indented(4, doc)

    def document_function(self, cls, name, obj):
        argspec = inspect.formatargspec(*inspect.getargspec(obj))
        self.print_indented(2, "{}.{}{}".format(cls.__name__, name, argspec))
        self.print_indented(4, inspect.getdoc(obj))

    def has_members(self, cls, include=None, exclude=None):
        for name, m in inspect.getmembers(cls):
            if name[0] == '_':
                continue
            if include is not None and name not in include:
                continue
            if exclude is not None and name in exclude:
                continue
            if inspect.isroutine(m):
                return True
            elif inspect.isfunction(m):
                return True
            elif inspect.isclass(m) or inspect.ismodule(m):
                pass
            elif m.__class__.__name__ == "_Feature":
                pass
            else:
                return True

    def document_members(self, cls, include=None, exclude=None):
        # List and classify members
        member_vars = []
        member_cfuncs = []
        member_funcs = []

        for name, m in inspect.getmembers(cls):
            if name[0] == '_':
                continue
            if include is not None and name not in include:
                continue
            if exclude is not None and name in exclude:
                continue
            if inspect.isroutine(m):
                member_cfuncs.append((name, m))
            elif inspect.isfunction(m):
                member_funcs.append((name, m))
            elif inspect.isclass(m) or inspect.ismodule(m):
                pass
            elif m.__class__.__name__ == "_Feature":
                pass
            else:
                member_vars.append((name, m))

        member_vars.sort()
        member_cfuncs.sort()
        member_funcs.sort()

        # Hyperlink destinations
        for name, m in member_vars:
            self.print(".. _{}.{}:".format(cls.__name__, name))
        for name, m in member_cfuncs:
            self.print(".. _{}.{}():".format(cls.__name__, name))
        for name, m in member_funcs:
            self.print(".. _{}.{}():".format(cls.__name__, name))

        # Document vars and get/setters
        self.spacer()
        for name, m in member_vars:
            self.document_getsetter(cls, name, m)

        # Document C functions
        for name, m in member_cfuncs:
            self.document_cfunction(cls, name, m)

        # Document functions
        for name, m in member_funcs:
            self.document_function(cls, name, m)

        self.spacer()


c_argspecs = {
    "dballe.varinfo": "(varcode)",
    "dballe.var": "(varcode[, default])",
    "dballe.describe_level": "(ltype1=None, l1=None, ltype2=None, l2=None)",
    "dballe.describe_trange": "(pind=None, p1=None, p2=None)",
    "Transaction.commit": "()",
    "Transaction.rollback": "()",
    "DB.get_default_format": "()",
    "DB.set_default_format": "(fmt: str)",
    "DB.connect_from_file": "(filename: str)",
    "DB.connect_from_url": "(url: str)",
    "DB.connect_test": "()",
    "DB.is_url": "(url: str)",
    "DB.transaction": "()",
    "DB.disappear": "()",
    "DB.reset": "(repinfo_filename: str=None)",
    "DB.insert": "(record: Union[dballe.Record, dict], can_replace: bool=False, can_add_stations: bool=False)",
    "DB.remove": "(query: Union[dballe.Record, dict])",
    "DB.vacuum": "()",
    "DB.query_attrs": "(query: Union[dballe.Record, dict])",
    "Cursor.attr_query": "()",
}

for meth, args in [
            ("attr_insert_data", "(data_id: int, attrs: Union[dballe.Record, dict])"),
            ("attr_insert_station", "(data_id: int, attrs: Union[dballe.Record, dict])"),
            ("attr_query_data", "(data_id: int)"),
            ("attr_query_station", "(data_id: int)"),
            ("attr_remove_data", "(data_id: int, attrs: Union[dballe.Record, dict]=None)"),
            ("attr_remove_station", "(data_id: int, attrs: Union[dballe.Record, dict]=None)"),
            ("export_to_file", "(query: Union[dballe.Record, dict], format: str, filename: str, generic: bool=False)"),
            ("insert_data", "(record: Union[dballe.Record, dict], can_replace: bool=False, can_add_stations:bool=False)"),
            ("insert_station_data", "(record: Union[dballe.Record, dict], can_replace: bool=False, can_add_stations:bool=False)"),
            ("load", "(file: str)"),
            ("query_data", "(query: Union[dballe.Record, dict])"),
            ("query_station_data", "(query: Union[dballe.Record, dict])"),
            ("query_stations", "(query: Union[dballe.Record, dict])"),
            ("query_summary", "(query: Union[dballe.Record, dict])"),
            ("remove", "(query: Union[dballe.Record, dict])"),
            ("remove_all", "()"),
            ("remove_station_data", "(query: Union[dballe.Record, dict])"),
        ]:
    c_argspecs["Transaction." + meth] = args
    c_argspecs["DB." + meth] = args


gen = Generator()

gen.title("README for DB-All.e Python bindings", char="=", over=True)
gen.para("""
The DB-All.e Python bindings provide 2 levels of access to a DB-All.e database:
a complete API similar to the Fortran and C++ API, and a high-level API called
volnd that allows to automatically export matrices of data out of the database.

.. contents::
""")

gen.title("The DB-All.e API", char="=")

gen.para("""
The 'dballe' module has a few global methods:
""")

gen.document_members(dballe)

gen.para("""
and several classes, documented in their own sections.
""")

gen.document_class(dballe.Var)
gen.document_class(dballe.Varinfo)
gen.document_class(dballe.Vartable)
gen.document_class(dballe.Level)
gen.document_class(dballe.Trange)
gen.document_class(dballe.Station)
gen.document_class(dballe.DBStation)
gen.document_class(dballe.Record)
gen.document_class(dballe.BinaryMessage)
gen.document_class(dballe.File)
gen.document_class(dballe.Message)
gen.document_class(dballe.Importer)
gen.document_class(dballe.ImporterFile)
gen.document_class(dballe.Exporter)

gen.para("""
dballe.DB
---------

a DB is used to access the database.

Its members are:
""")

db_transaction_methods = [
        "attr_insert_data", "attr_insert_station", "attr_query_data",
        "attr_query_station", "attr_remove_data", "attr_remove_station",
        "export_to_file", "insert_data", "insert_station_data", "load",
        "query_data", "query_station_data", "query_stations", "query_summary",
        "remove", "remove_all", "remove_station_data"]
db_deprecated_methods = ["attr_insert", "attr_remove", "query_attrs"]

gen.document_members(dballe.DB, exclude=db_transaction_methods + db_deprecated_methods)

gen.para("""
These methods are the same in dballe.DB and dballe.Transaction. The version in
dballe.DB is implemented by automatically creating a temporary transaction and
running the dballe.Transaction method inside it.
""")

gen.document_members(dballe.DB, include=db_transaction_methods)

gen.para("""
dballe.Transaction
------------------

A Transaction is used to execute DB operations in an all-or-nothing fashion. In
fact, most DB methods are implemented using a short-lived temporary
transaction.

You cannot have more than one active dballe.Transaction for each dballe.DB. An
attempt to start a second one will result in an exception being raised. Note
that dballe.DB functions like `insert_data` or `export_to_file` create a
temporary transaction to run, and so they will also fail if a transaction is
currently open. The general idea is that all database work should be done
inside a transaction.

Transactions run using the `REPEATABLE READ` isolation level of the underlying
database. This usually means that modifications performed inside a transaction
are not visible to other database connections until the transaction is
committed. If a transaction is rolled back, all changes done with it are
undone.

Transactions can also be used as context managers, like this:

::

    with db.transaction() as t:
        for i in range(10):
            t.insert({
                "lat": 44.5 + i, "lon": 11.4 + i, "level": (1,),
                "trange": (254,), "date": datetime.datetime(2013, 4, 25, 12, 0, 0),
                "B11101": 22.4 + i, "B12103": 17.2
            })

Its members are:

""")

gen.document_members(dballe.Transaction, exclude=db_transaction_methods)

gen.para("""
The dballe.Transaction methods are the same as those in dballe.DB. The version
in dballe.DB is implemented by automatically creating a temporary transaction
and running the dballe.Transaction method inside it.
""")
gen.document_members(dballe.Transaction, include=db_transaction_methods)

gen.para("""

Examples:

::

    # Connect to a database and run a query
    db = dballe.DB.connect_from_file("db.sqlite")
    query = dballe.Record(latmin=44.0, latmax=45.0, lonmin=11.0, lonmax=12.0)

    # The result is a dballe.Cursor, which can be iterated to get results as
    # dballe.Record objects.
    # The results always point to the same Record to avoid creating a new one
    # for every iteration: if you need to store them, use Record.copy()
    for rec in db.query_data(query):
        print(rec["lat"], rec["lon"], rec["var"], rec.var().format("undefined"))

    # Insert 2 new variables in the database
    db.insert({
        "lat": 44.5, "lon": 11.4,
        "level": (1,),
        "trange": (254,),
        "date": datetime.datetime(2013, 4, 25, 12, 0, 0),
        "B11101": 22.4,
        "B12103": 17.2,
    })
""")


gen.para("""
dballe.Cursor
-------------

a Cursor is the result of database queries. It is generally not used explicitly
and just iterated, but it does have a few members:
""")

gen.document_members(dballe.Cursor)

gen.para("""
The volnd API
=============
""")

gen.document(dballe.volnd)

gen.para("""
This is the list of dimensions supported by dballe.volnd:
""")

gen.document(dballe.volnd.AnaIndex)
gen.document(dballe.volnd.NetworkIndex)
gen.document(dballe.volnd.LevelIndex)
gen.document(dballe.volnd.TimeRangeIndex)
gen.document(dballe.volnd.DateTimeIndex)
gen.document(dballe.volnd.IntervalIndex)

gen.para("""
The data object used by ``AnaIndex`` is:
""")

gen.document(dballe.volnd.AnaIndexEntry)

gen.para("""
The extraction is done using the dballe.volnd.read function:
""")

gen.document(dballe.volnd.read)

gen.para("""
The result of dballe.volnd.read is a dict mapping output variable names to a
dballe.volnd.Data object with the results.  All the Data objects share their
indexes unless the *xxx*-Index definitions have been created with
``shared=False``.

This is the dballe.volnd.Data class documentation:
""")

gen.document(dballe.volnd.Data)

gen.para("""
The methods of dballe.volnd.Data are:
""")

gen.document_members(dballe.volnd.Data)
