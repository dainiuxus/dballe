#!/usr/bin/python3

import os
os.environ["DBALLE_BUILDING_DOCS"] = "true"  # noqa
import sys
import re
import inspect
import dballe
import dballe.volnd

re_docparsep = re.compile(r"\n(?:\s*\n)+")
re_signature = re.compile(r"\S+\(.*\)")
re_linebreak = re.compile(r"\s*\n\s*")


def split_doc_summary(doc):
    res = re_docparsep.split(doc, maxsplit=1)
    if len(res) == 1:
        dstrip = doc.strip()
        if "\n" in dstrip:
            return None, doc
        else:
            return doc, None
    else:
        summary = re_linebreak.sub(" ", res[0])
        return summary, res[1]


class Generator:
    def __init__(self):
        self.whitespace = True

    def spacer(self):
        if self.whitespace:
            return
        print()
        self.whitespace = True

    def print(self, *args, **kw):
        self.whitespace = False
        print(*args, **kw)

    def print_indented(self, spaces, *args):
        "Print a string, indented by the given number of spaces"
        self.whitespace = False
        for s in args:
            for line in s.split("\n"):
                for i in range(1, spaces):
                    sys.stdout.write(" ")
                sys.stdout.write(line.replace("wreport.", "dballe."))
                sys.stdout.write("\n")

    def text(self, text: str):
        self.print(text.lstrip())

    def para(self, text: str):
        if not self.whitespace:
            print()
        print(text.lstrip())
        print()
        self.whitespace = True

    def title(self, line, char='-', over=False):
        self.spacer()
        if over:
            print(char * len(line))
        print(line)
        print(char * len(line))
        print()

    def document_class(self, cls, **kw):
        name = cls.__name__
        self.title("dballe.{}".format(name))
        self.print(inspect.getdoc(cls).replace("wreport.", "dballe."))
        if self.has_members(cls, **kw):
            self.title("Members", char="`")
            self.document_members(cls, **kw)
        self.spacer()

    def document(self, obj):
        if obj.__doc__ is None:
            return

        if inspect.ismodule(obj):
            self.print_indented(0, inspect.getdoc(obj))
            self.spacer()
        elif inspect.isroutine(obj) and inspect.isfunction(obj):
            # A Python function
            self.print_indented(2, '``'+obj.__name__ + inspect.formatargspec(*inspect.getargspec(obj))+"``")
            self.print_indented(4, inspect.getdoc(obj))
        else:
            self.print_indented(2, obj.__name__)
            self.print_indented(4, inspect.getdoc(obj))

    def document_getsetter(self, cls, name, obj):
        doc = inspect.getdoc(obj)

        summary, rest = split_doc_summary(doc)
        if summary:
            if rest:
                self.print_indented(2, "{}.{}: {}".format(cls.__name__, name, summary))
                self.print_indented(4, rest)
            else:
                self.print_indented(2, "{}.{}".format(cls.__name__, name))
                self.print_indented(4, summary)
        else:
            self.print_indented(2, "{}.{}".format(cls.__name__, name))
            self.print_indented(4, doc)

    def document_cfunction(self, cls, name, obj):
        # Split signature and summary
        doc = inspect.getdoc(obj)

        signature, rest = split_doc_summary(doc)
        if signature and re_signature.search(signature):
            if signature.startswith(cls.__name__ + "."):
                signature = signature[len(cls.__name__) + 1:]
            self.print_indented(2, "{}.{}".format(cls.__name__, signature))
            if rest:
                self.print_indented(4, rest)
        else:
            self.print_indented(2, "{}.{}(â€¦)".format(cls.__name__, name))
            self.print_indented(4, doc)

    def document_function(self, cls, name, obj):
        argspec = inspect.formatargspec(*inspect.getargspec(obj))
        self.print_indented(2, "{}.{}{}".format(cls.__name__, name, argspec))
        self.print_indented(4, inspect.getdoc(obj))

    def has_members(self, cls, include=None, exclude=None):
        for name, m in inspect.getmembers(cls):
            if name[0] == '_':
                continue
            if include is not None and name not in include:
                continue
            if exclude is not None and name in exclude:
                continue
            if inspect.isroutine(m):
                return True
            elif inspect.isfunction(m):
                return True
            elif inspect.isclass(m) or inspect.ismodule(m):
                pass
            elif m.__class__.__name__ == "_Feature":
                pass
            else:
                return True

    def document_members(self, cls, include=None, exclude=None):
        # List and classify members
        member_vars = []
        member_cfuncs = []
        member_funcs = []

        for name, m in inspect.getmembers(cls):
            if name[0] == '_':
                continue
            if include is not None and name not in include:
                continue
            if exclude is not None and name in exclude:
                continue
            if inspect.isroutine(m):
                member_cfuncs.append((name, m))
            elif inspect.isfunction(m):
                member_funcs.append((name, m))
            elif inspect.isclass(m) or inspect.ismodule(m):
                pass
            elif m.__class__.__name__ == "_Feature":
                pass
            else:
                member_vars.append((name, m))

        member_vars.sort()
        member_cfuncs.sort()
        member_funcs.sort()

        # Hyperlink destinations
        for name, m in member_vars:
            self.print(".. _{}.{}:".format(cls.__name__, name))
        for name, m in member_cfuncs:
            self.print(".. _{}.{}():".format(cls.__name__, name))
        for name, m in member_funcs:
            self.print(".. _{}.{}():".format(cls.__name__, name))

        # Document vars and get/setters
        self.spacer()
        for name, m in member_vars:
            self.document_getsetter(cls, name, m)

        # Document C functions
        for name, m in member_cfuncs:
            self.document_cfunction(cls, name, m)

        # Document functions
        for name, m in member_funcs:
            self.document_function(cls, name, m)

        self.spacer()


gen = Generator()

gen.title("README for DB-All.e Python bindings", char="=", over=True)
gen.para("""
The DB-All.e Python bindings provide 2 levels of access to a DB-All.e database:
a complete API similar to the Fortran and C++ API, and a high-level API called
volnd that allows to automatically export matrices of data out of the database.

.. contents::
""")

gen.title("The DB-All.e API", char="=")

gen.para("""
The 'dballe' module has a few global methods:
""")

gen.document_members(dballe)

gen.para("""
and several classes, documented in their own sections.
""")

gen.document_class(dballe.Var)
gen.document_class(dballe.Varinfo)
gen.document_class(dballe.Vartable)
gen.document_class(dballe.Level)
gen.document_class(dballe.Trange)
gen.document_class(dballe.Station)
gen.document_class(dballe.DBStation)
gen.document_class(dballe.BinaryMessage)
gen.document_class(dballe.File)
gen.document_class(dballe.Message)
gen.document_class(dballe.Importer)
gen.document_class(dballe.ImporterFile)
gen.document_class(dballe.Exporter)
gen.document_class(dballe.DB, exclude=("attr_insert", "attr_remove", "query_attrs", "load", "export_to_file"))
gen.document_class(dballe.Transaction, exclude=("load", "export_to_file"))
gen.document_class(dballe.Cursor, exclude=("query_attrs"))


gen.para("""
The volnd API
=============
""")

gen.document(dballe.volnd)

gen.para("""
This is the list of dimensions supported by dballe.volnd:
""")

gen.document(dballe.volnd.AnaIndex)
gen.document(dballe.volnd.NetworkIndex)
gen.document(dballe.volnd.LevelIndex)
gen.document(dballe.volnd.TimeRangeIndex)
gen.document(dballe.volnd.DateTimeIndex)
gen.document(dballe.volnd.IntervalIndex)

gen.para("""
The data object used by ``AnaIndex`` is:
""")

gen.document(dballe.volnd.AnaIndexEntry)

gen.para("""
The extraction is done using the dballe.volnd.read function:
""")

gen.document(dballe.volnd.read)

gen.para("""
The result of dballe.volnd.read is a dict mapping output variable names to a
dballe.volnd.Data object with the results.  All the Data objects share their
indexes unless the *xxx*-Index definitions have been created with
``shared=False``.

This is the dballe.volnd.Data class documentation:
""")

gen.document(dballe.volnd.Data)

gen.para("""
The methods of dballe.volnd.Data are:
""")

gen.document_members(dballe.volnd.Data)
