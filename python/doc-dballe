#!/usr/bin/python3

import os
os.environ["DBALLE_BUILDING_DOCS"] = "true"  # noqa

import sys
import inspect
import dballe
import dballe.volnd


class Generator:
    def __init__(self):
        self.whitespace = True

    def spacer(self):
        if self.whitespace:
            return
        print()
        self.whitespace = True

    def print(self, *args, **kw):
        self.whitespace = False
        print(*args, **kw)

    def print_indented(self, spaces, *args):
        "Print a string, indented by the given number of spaces"
        self.whitespace = False
        for s in args:
            for line in s.split("\n"):
                for i in range(1, spaces):
                    sys.stdout.write(" ")
                sys.stdout.write(line.replace("wreport.", "dballe."))
                sys.stdout.write("\n")

    def text(self, text: str):
        self.print(text.lstrip())

    def para(self, text: str):
        if not self.whitespace:
            print()
        print(text.lstrip())
        print()
        self.whitespace = True

    def title(self, line, char='-', over=False):
        self.spacer()
        if over:
            print(char * len(line))
        print(line)
        print(char * len(line))
        print()

    def document_class(self, cls):
        name = cls.__name__
        self.title("dballe.{}".format(name))
        self.print(inspect.getdoc(cls).replace("wreport.", "dballe."))
        self.title("Members", char="`")
        self.document_members(cls)
        self.spacer()

    def document(self, obj):
        if obj.__doc__ is None:
            return

        if inspect.ismodule(obj):
            self.print_indented(0, inspect.getdoc(obj))
            self.spacer()
        elif inspect.isroutine(obj) and inspect.isfunction(obj):
            # A Python function
            self.print_indented(2, '``'+obj.__name__ + inspect.formatargspec(*inspect.getargspec(obj))+"``")
            self.print_indented(4, inspect.getdoc(obj))
        else:
            self.print_indented(2, obj.__name__)
            self.print_indented(4, inspect.getdoc(obj))

    def document_members(self, cls, include=None, exclude=None):
        # List and classify members
        member_vars = []
        member_funcs = []

        for name, m in inspect.getmembers(cls):
            if name[0] == '_':
                continue
            if include is not None and name not in include:
                continue
            if exclude is not None and name in exclude:
                continue
            fullname = cls.__name__ + "." + name
            if inspect.isroutine(m) and (inspect.isfunction(m) or fullname in c_argspecs):
                member_funcs.append((fullname, name, m))
            elif inspect.isclass(m) or inspect.ismodule(m):
                pass
            elif m.__class__.__name__ == "_Feature":
                pass
            else:
                member_vars.append((fullname, name, m))

        member_vars.sort()
        member_funcs.sort()

        # Document vars and get/setters
        for fullname, name, m in member_vars:
            self.print(".. _{}.{}:".format(cls.__name__, name))
        for fullname, name, m in member_funcs:
            self.print(".. _{}.{}():".format(cls.__name__, name))
        self.spacer()
        for fullname, name, m in member_vars:
            self.print_indented(2, "{}.{}".format(cls.__name__, name))
            self.print_indented(4, inspect.getdoc(m))

        # Document functions
        for fullname, name, m in member_funcs:
            argspec = c_argspecs.get(fullname, None)
            if argspec is None:
                if inspect.isfunction(m):
                    argspec = inspect.formatargspec(*inspect.getargspec(m))
                else:
                    argspec = ""
            self.print_indented(2, "{}.{}{}".format(cls.__name__, name, argspec))
            self.print_indented(4, inspect.getdoc(m))

        self.spacer()


c_argspecs = {
    "dballe.varinfo": "(varcode)",
    "dballe.var": "(varcode[, default])",
    "dballe.describe_level": "(ltype1=None, l1=None, ltype2=None, l2=None)",
    "dballe.describe_trange": "(pind=None, p1=None, p2=None)",
    "Var.enqi": "()",
    "Var.enqc": "()",
    "Var.enqd": "()",
    "Var.enq": "()",
    "Var.get": "(default=None)",
    "Var.format": "(default='')",
    "Record.to_dict": "()",
    "Record.clear": "()",
    "Record.clear_vars": "()",
    "Record.get": "(key, default=None)",
    "Record.copy": "()",
    "Record.key": "(key)",
    "Record.var": "(key)",
    "Record.keys": "()",
    "Record.items": "()",
    "Record.varitems": "()",
    "Record.vars": "()",
    "Record.update": "(\\*\\*kwargs)",
    "Record.date_extremes": "()",
    "Record.set_from_string": "(str)",
    "Transaction.commit": "()",
    "Transaction.rollback": "()",
    "DB.get_default_format": "()",
    "DB.set_default_format": "(fmt: str)",
    "DB.connect_from_file": "(filename: str)",
    "DB.connect_from_url": "(url: str)",
    "DB.connect_test": "()",
    "DB.is_url": "(url: str)",
    "DB.transaction": "()",
    "DB.disappear": "()",
    "DB.reset": "(repinfo_filename: str=None)",
    "DB.insert": "(record: Union[dballe.Record, dict], can_replace: bool=False, can_add_stations: bool=False)",
    "DB.remove": "(query: Union[dballe.Record, dict])",
    "DB.vacuum": "()",
    "DB.query_attrs": "(query: Union[dballe.Record, dict])",
    "Cursor.attr_query": "()",
}

for meth, args in [
            ("attr_insert_data", "(data_id: int, attrs: Union[dballe.Record, dict])"),
            ("attr_insert_station", "(data_id: int, attrs: Union[dballe.Record, dict])"),
            ("attr_query_data", "(data_id: int)"),
            ("attr_query_station", "(data_id: int)"),
            ("attr_remove_data", "(data_id: int, attrs: Union[dballe.Record, dict]=None)"),
            ("attr_remove_station", "(data_id: int, attrs: Union[dballe.Record, dict]=None)"),
            ("export_to_file", "(query: Union[dballe.Record, dict], format: str, filename: str, generic: bool=False)"),
            ("insert_data", "(record: Union[dballe.Record, dict], can_replace: bool=False, can_add_stations:bool=False)"),
            ("insert_station_data", "(record: Union[dballe.Record, dict], can_replace: bool=False, can_add_stations:bool=False)"),
            ("load", "(file: str)"),
            ("query_data", "(query: Union[dballe.Record, dict])"),
            ("query_station_data", "(query: Union[dballe.Record, dict])"),
            ("query_stations", "(query: Union[dballe.Record, dict])"),
            ("query_summary", "(query: Union[dballe.Record, dict])"),
            ("remove", "(query: Union[dballe.Record, dict])"),
            ("remove_all", "()"),
            ("remove_station_data", "(query: Union[dballe.Record, dict])"),
        ]:
    c_argspecs["Transaction." + meth] = args
    c_argspecs["DB." + meth] = args


gen = Generator()

gen.title("README for DB-All.e Python bindings", char="=", over=True)
gen.para("""
The DB-All.e Python bindings provide 2 levels of access to a DB-All.e database:
a complete API similar to the Fortran and C++ API, and a high-level API called
volnd that allows to automatically export matrices of data out of the database.

.. contents::
""")

gen.title("The DB-All.e API", char="=")

gen.para("""
The 'dballe' module has a few global methods:
""")

gen.document_members(dballe)

gen.para("""
and several classes, documented in their own sections.
""")

gen.document_class(dballe.Var)
gen.document_class(dballe.Varinfo)
gen.document_class(dballe.Vartable)
gen.document_class(dballe.Record)

gen.para("""
Note that all the functions that take a dballe.Record, can also take a Python dict.
""")

gen.para("""
dballe.DB
---------

a DB is used to access the database.

Its members are:
""")

db_transaction_methods = [
        "attr_insert_data", "attr_insert_station", "attr_query_data",
        "attr_query_station", "attr_remove_data", "attr_remove_station",
        "export_to_file", "insert_data", "insert_station_data", "load",
        "query_data", "query_station_data", "query_stations", "query_summary",
        "remove", "remove_all", "remove_station_data"]
db_deprecated_methods = ["attr_insert", "attr_remove", "query_attrs"]

gen.document_members(dballe.DB, exclude=db_transaction_methods + db_deprecated_methods)

gen.para("""
These methods are the same in dballe.DB and dballe.Transaction. The version in
dballe.DB is implemented by automatically creating a temporary transaction and
running the dballe.Transaction method inside it.
""")

gen.document_members(dballe.DB, include=db_transaction_methods)

gen.para("""
dballe.Transaction
------------------

A Transaction is used to execute DB operations in an all-or-nothing fashion. In
fact, most DB methods are implemented using a short-lived temporary
transaction.

You cannot have more than one active dballe.Transaction for each dballe.DB. An
attempt to start a second one will result in an exception being raised. Note
that dballe.DB functions like `insert_data` or `export_to_file` create a
temporary transaction to run, and so they will also fail if a transaction is
currently open. The general idea is that all database work should be done
inside a transaction.

Transactions run using the `REPEATABLE READ` isolation level of the underlying
database. This usually means that modifications performed inside a transaction
are not visible to other database connections until the transaction is
committed. If a transaction is rolled back, all changes done with it are
undone.

Transactions can also be used as context managers, like this:

::

    with db.transaction() as t:
        for i in range(10):
            t.insert({
                "lat": 44.5 + i, "lon": 11.4 + i, "level": (1,),
                "trange": (254,), "date": datetime.datetime(2013, 4, 25, 12, 0, 0),
                "B11101": 22.4 + i, "B12103": 17.2
            })

Its members are:

""")

gen.document_members(dballe.Transaction, exclude=db_transaction_methods)

gen.para("""
The dballe.Transaction methods are the same as those in dballe.DB. The version
in dballe.DB is implemented by automatically creating a temporary transaction
and running the dballe.Transaction method inside it.
""")
gen.document_members(dballe.Transaction, include=db_transaction_methods)

gen.para("""

Examples:

::

    # Connect to a database and run a query
    db = dballe.DB.connect_from_file("db.sqlite")
    query = dballe.Record(latmin=44.0, latmax=45.0, lonmin=11.0, lonmax=12.0)

    # The result is a dballe.Cursor, which can be iterated to get results as
    # dballe.Record objects.
    # The results always point to the same Record to avoid creating a new one
    # for every iteration: if you need to store them, use Record.copy()
    for rec in db.query_data(query):
        print(rec["lat"], rec["lon"], rec["var"], rec.var().format("undefined"))

    # Insert 2 new variables in the database
    db.insert({
        "lat": 44.5, "lon": 11.4,
        "level": (1,),
        "trange": (254,),
        "date": datetime.datetime(2013, 4, 25, 12, 0, 0),
        "B11101": 22.4,
        "B12103": 17.2,
    })
""")


gen.para("""
dballe.Cursor
-------------

a Cursor is the result of database queries. It is generally not used explicitly
and just iterated, but it does have a few members:
""")

gen.document_members(dballe.Cursor)

gen.para("""
The volnd API
=============
""")

gen.document(dballe.volnd)

gen.para("""
This is the list of dimensions supported by dballe.volnd:
""")

gen.document(dballe.volnd.AnaIndex)
gen.document(dballe.volnd.NetworkIndex)
gen.document(dballe.volnd.LevelIndex)
gen.document(dballe.volnd.TimeRangeIndex)
gen.document(dballe.volnd.DateTimeIndex)
gen.document(dballe.volnd.IntervalIndex)

gen.para("""
The data object used by ``AnaIndex`` is:
""")

gen.document(dballe.volnd.AnaIndexEntry)

gen.para("""
The extraction is done using the dballe.volnd.read function:
""")

gen.document(dballe.volnd.read)

gen.para("""
The result of dballe.volnd.read is a dict mapping output variable names to a
dballe.volnd.Data object with the results.  All the Data objects share their
indexes unless the *xxx*-Index definitions have been created with
``shared=False``.

This is the dballe.volnd.Data class documentation:
""")

gen.document(dballe.volnd.Data)

gen.para("""
The methods of dballe.volnd.Data are:
""")

gen.document_members(dballe.volnd.Data)
